Stack has not been tested with GHC versions above 9.0, and using 9.2.2, this may fail
Stack has not been tested with Cabal versions above 3.4, but version 3.8.1.0 was found, this may fail
HaskellDebug-0.1.0.0: unregistering (local file changes: src/HeapUtils.hs)
HaskellDebug> build (lib + exe)
Preprocessing library for HaskellDebug-0.1.0.0..
Building library for HaskellDebug-0.1.0.0..
[7 of 9] Compiling HeapUtils [Source file changed]

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:1:1: warning: [-Wmissing-export-lists]
    The export item ‘module HeapUtils’ is missing an export list
  |
1 | {-# LANGUAGE RecordWildCards #-}
  | ^

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:23:41: warning: [-Wunused-imports]
    The import of ‘isJust’ from module ‘Data.Maybe’ is redundant
   |
23 | import Data.Maybe (catMaybes, fromJust, isJust)
   |                                         ^^^^^^

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:37:1: warning: [-Wunused-imports]
    The qualified import of ‘Data.IntSet’ is redundant
      except perhaps to import instances from ‘Data.IntSet’
    To import instances alone, use: import Data.IntSet()
   |
37 | import qualified Data.IntSet as IS
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:39:1: warning: [-Wunused-imports]
    The import of ‘Debug.Trace’ is redundant
      except perhaps to import instances from ‘Debug.Trace’
    To import instances alone, use: import Debug.Trace()
   |
39 | import Debug.Trace
   | ^^^^^^^^^^^^^^^^^^

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:44:1: warning: [-Wunused-imports]
    The qualified import of ‘Data.Text.Array’ is redundant
      except perhaps to import instances from ‘Data.Text.Array’
    To import instances alone, use: import Data.Text.Array()
   |
44 | import qualified Data.Text.Array as A
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:353:52: warning: [-Wtype-defaults]
    • Defaulting the type variable ‘a0’ to type ‘Integer’ in the following constraints
        (Ord a0) arising from a use of ‘>’ at src/HeapUtils.hs:353:52
        (Num a0) arising from the literal ‘1’ at src/HeapUtils.hs:353:54
    • In the expression: (>)
      In the first argument of ‘filter’, namely ‘(> 1)’
      In the first argument of ‘($)’, namely ‘filter (> 1)’
    |
353 |     bindings = nubOrd $ (0:) $ M.keys $  M.filter (> 1) $ M.fromListWith (+) $ map (,1) $ concatMap (catMaybes . allClosures . hgeClosure) (IM.elems m)
    |                                                    ^

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 4,038, types: 8,710, coercions: 1,064, joins: 3/79}

$p1MonadHeapPrint
  = \ @k[sk:1] @m[sk:1] v ->
      case v of v { C:MonadHeapPrint v v v -> v }

getHeapBindings
  = \ @k[sk:1] @m[sk:1] v ->
      case v of v { C:MonadHeapPrint v v v -> v }

getHeapContent
  = \ @k[sk:1] @m[sk:1] v ->
      case v of v { C:MonadHeapPrint v v v -> v }

$p1MonadDecorate
  = \ @m[sk:1] v -> case v of v { C:MonadDecorate v v -> v }

decorateMap
  = \ @m[sk:1] v -> case v of v { C:MonadDecorate v v -> v }

$p1PrintClosure
  = \ @k[sk:1] @k[sk:1] @r[sk:1] @t[sk:1] @f[sk:1] @m[sk:1] v ->
      case v of v { C:PrintClosure v v -> v }

pClosImpl
  = \ @k[sk:1] @k[sk:1] @r[sk:1] @t[sk:1] @f[sk:1] @m[sk:1] v ->
      case v of v { C:PrintClosure v v -> v }

$cpClosImpl
  = \ @k @k1 @m @r @t @f $dApplicative1 _ _ _ _ ->
      pure
        $dApplicative1 ($fIsStringDoc_$cfromString (unpackCString# "..."#))

$fPrintClosurekTYPErElidetm
  = \ @k @k1 @m @r @t @f $dApplicative1 ->
      C:PrintClosure $dApplicative1 ($cpClosImpl $dApplicative1)

$cp1PrintClosure
  = \ @k @k1 @m @r @f @t $dMonadDecorate2 _ ->
      $p1Monad ($p1MonadDecorate $dMonadDecorate2)

$cp1PrintClosure1
  = \ @k @k1 @r @x @m _ $dMonadDecorate2 ->
      $p1Monad ($p1MonadDecorate $dMonadDecorate2)

$cp1PrintClosure2
  = \ @k @k1 @r @x @b @m _ $dMonadDecorate2 ->
      $p1Monad ($p1MonadDecorate $dMonadDecorate2)

$cp1PrintClosure3
  = \ @k @b @m @r $dMonadHeapPrint1 _ ->
      $p1Monad ($p1MonadHeapPrint $dMonadHeapPrint1)

$cp1PrintClosure4
  = \ @k @k1 @b @m @r @f $dMonadHeapPrint1 _ ->
      $p1Monad ($p1MonadHeapPrint $dMonadHeapPrint1)

$cp1PrintClosure5
  = \ @k @r @t @m _ $dMonadHeapPrint1 ->
      $p1Monad ($p1MonadHeapPrint $dMonadHeapPrint1)

$cp1PrintClosure6
  = \ @k @r @t @m _ $dMonadHeapPrint1 ->
      $p1Monad ($p1MonadHeapPrint $dMonadHeapPrint1)

$cgetHeapContent
  = \ @m @t $dMonad1 eta -> return $dMonad1 (fst eta)

$cgetHeapBindings
  = \ @m @t $dMonad1 eta -> return $dMonad1 (snd eta)

$clift = \ @m @a _ eta _ -> eta

$fMonadTransDecorateT
  = $clift
    `cast` <Co:28> :: (forall {m :: * -> *} {a}.
                       Monad m =>
                       m a -> IntMap Attr -> m a)
                      ~R# MonadTrans DecorateT

$fFunctorDecorateT
  = \ @m $dFunctor ->
      C:Functor
        ((\ @a @b -> ($fFunctorReaderT_$cfmap $dFunctor))
         `cast` <Co:18> :: (forall {a} {b}.
                            (a -> b) -> ReaderT (IntMap Attr) m a -> ReaderT (IntMap Attr) m b)
                           ~R# (forall {a} {b}. (a -> b) -> DecorateT m a -> DecorateT m b))
        ((\ @a @b -> ($fFunctorReaderT_$c<$ $dFunctor))
         `cast` <Co:17> :: (forall {a} {b}.
                            a -> ReaderT (IntMap Attr) m b -> ReaderT (IntMap Attr) m a)
                           ~R# (forall {a} {b}. a -> DecorateT m b -> DecorateT m a))

$cp1Applicative
  = \ @m $dApplicative1 ->
      $fFunctorDecorateT ($p1Applicative $dApplicative1)

$fApplicativeDecorateT
  = \ @m $dApplicative1 ->
      C:Applicative
        ($cp1Applicative $dApplicative1)
        ((\ @a -> ($fApplicativeReaderT_$cpure $dApplicative1))
         `cast` <Co:9> :: (forall {a}. a -> ReaderT (IntMap Attr) m a)
                          ~R# (forall {a}. a -> DecorateT m a))
        ((\ @a @b -> ($fApplicativeReaderT_$c<*> $dApplicative1))
         `cast` <Co:21> :: (forall {a} {b}.
                            ReaderT (IntMap Attr) m (a -> b)
                            -> ReaderT (IntMap Attr) m a -> ReaderT (IntMap Attr) m b)
                           ~R# (forall {a} {b}.
                                DecorateT m (a -> b) -> DecorateT m a -> DecorateT m b))
        ((\ @a @b @c -> ($fApplicativeReaderT_$cliftA2 $dApplicative1))
         `cast` <Co:27> :: (forall {a} {b} {c}.
                            (a -> b -> c)
                            -> ReaderT (IntMap Attr) m a
                            -> ReaderT (IntMap Attr) m b
                            -> ReaderT (IntMap Attr) m c)
                           ~R# (forall {a} {b} {c}.
                                (a -> b -> c) -> DecorateT m a -> DecorateT m b -> DecorateT m c))
        ((\ @a @b -> ($fApplicativeReaderT_$c*> $dApplicative1))
         `cast` <Co:20> :: (forall {a} {b}.
                            ReaderT (IntMap Attr) m a
                            -> ReaderT (IntMap Attr) m b -> ReaderT (IntMap Attr) m b)
                           ~R# (forall {a} {b}.
                                DecorateT m a -> DecorateT m b -> DecorateT m b))
        ((\ @a @b -> ($fApplicativeReaderT_$c<* $dApplicative1))
         `cast` <Co:20> :: (forall {a} {b}.
                            ReaderT (IntMap Attr) m a
                            -> ReaderT (IntMap Attr) m b -> ReaderT (IntMap Attr) m a)
                           ~R# (forall {a} {b}.
                                DecorateT m a -> DecorateT m b -> DecorateT m a))

$cp1Monad
  = \ @m $dMonad1 -> $fApplicativeDecorateT ($p1Monad $dMonad1)

$fMonadDecorateT
  = \ @m $dMonad1 ->
      C:Monad
        ($cp1Monad $dMonad1)
        ((\ @a @b -> ($fMonadReaderT_$c>>= $dMonad1))
         `cast` <Co:23> :: (forall {a} {b}.
                            ReaderT (IntMap Attr) m a
                            -> (a -> ReaderT (IntMap Attr) m b) -> ReaderT (IntMap Attr) m b)
                           ~R# (forall {a} {b}.
                                DecorateT m a -> (a -> DecorateT m b) -> DecorateT m b))
        ((\ @a @b -> ($fMonadReaderT_$c>> $dMonad1))
         `cast` <Co:20> :: (forall {a} {b}.
                            ReaderT (IntMap Attr) m a
                            -> ReaderT (IntMap Attr) m b -> ReaderT (IntMap Attr) m b)
                           ~R# (forall {a} {b}.
                                DecorateT m a -> DecorateT m b -> DecorateT m b))
        ((\ @a -> ($fMonadReaderT_$creturn $dMonad1))
         `cast` <Co:9> :: (forall {a}. a -> ReaderT (IntMap Attr) m a)
                          ~R# (forall {a}. a -> DecorateT m a))

$cp1MonadHeapPrint
  = \ @t @m $dMonadHeapPrint1 ->
      $fMonadDecorateT ($p1MonadHeapPrint $dMonadHeapPrint1)

$fMonadDecorateDecorateT
  = \ @m $dMonad1 ->
      C:MonadDecorate
        ($fMonadDecorateT $dMonad1)
        ((return $dMonad1)
         `cast` <Co:13> :: (IntMap Attr -> m (IntMap Attr))
                           ~R# DecorateT m (IntMap Attr))

$cstate
  = \ @s @t @m $dMonadState @a ->
      (state ($fMonadStatesReaderT $dMonadState))

$cput
  = \ @s @t @m $dMonadState ->
      put ($fMonadStatesReaderT $dMonadState)

$cget
  = \ @s @t @m $dMonadState ->
      get ($fMonadStatesReaderT $dMonadState)

$clift1 = \ @t @m @a _ eta _ -> eta

$fMonadTransHeapPrintT
  = $clift1
    `cast` <Co:35> :: (forall {t} {m :: * -> *} {a}.
                       Monad m =>
                       m a -> (HeapGraph t, IntMap String) -> m a)
                      ~R# (forall {t}. MonadTrans (HeapPrintT t))

$fFunctorHeapPrintT
  = \ @t @m $dFunctor ->
      C:Functor
        ((\ @a @b -> ($fFunctorReaderT_$cfmap $dFunctor))
         `cast` <Co:20> :: (forall {a} {b}.
                            (a -> b)
                            -> ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b)
                           ~R# (forall {a} {b}.
                                (a -> b) -> HeapPrintT t m a -> HeapPrintT t m b))
        ((\ @a @b -> ($fFunctorReaderT_$c<$ $dFunctor))
         `cast` <Co:19> :: (forall {a} {b}.
                            a
                            -> ReaderT (HeapGraph t, IntMap String) m b
                            -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a} {b}. a -> HeapPrintT t m b -> HeapPrintT t m a))

$cp1Applicative1
  = \ @t @m $dApplicative1 ->
      $fFunctorHeapPrintT ($p1Applicative $dApplicative1)

$fApplicativeHeapPrintT
  = \ @t @m $dApplicative1 ->
      C:Applicative
        ($cp1Applicative1 $dApplicative1)
        ((\ @a -> ($fApplicativeReaderT_$cpure $dApplicative1))
         `cast` <Co:10> :: (forall {a}.
                            a -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a}. a -> HeapPrintT t m a))
        ((\ @a @b -> ($fApplicativeReaderT_$c<*> $dApplicative1))
         `cast` <Co:24> :: (forall {a} {b}.
                            ReaderT (HeapGraph t, IntMap String) m (a -> b)
                            -> ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b)
                           ~R# (forall {a} {b}.
                                HeapPrintT t m (a -> b) -> HeapPrintT t m a -> HeapPrintT t m b))
        ((\ @a @b @c -> ($fApplicativeReaderT_$cliftA2 $dApplicative1))
         `cast` <Co:30> :: (forall {a} {b} {c}.
                            (a -> b -> c)
                            -> ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b
                            -> ReaderT (HeapGraph t, IntMap String) m c)
                           ~R# (forall {a} {b} {c}.
                                (a -> b -> c)
                                -> HeapPrintT t m a -> HeapPrintT t m b -> HeapPrintT t m c))
        ((\ @a @b -> ($fApplicativeReaderT_$c*> $dApplicative1))
         `cast` <Co:23> :: (forall {a} {b}.
                            ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b
                            -> ReaderT (HeapGraph t, IntMap String) m b)
                           ~R# (forall {a} {b}.
                                HeapPrintT t m a -> HeapPrintT t m b -> HeapPrintT t m b))
        ((\ @a @b -> ($fApplicativeReaderT_$c<* $dApplicative1))
         `cast` <Co:23> :: (forall {a} {b}.
                            ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b
                            -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a} {b}.
                                HeapPrintT t m a -> HeapPrintT t m b -> HeapPrintT t m a))

$cp1Monad1
  = \ @t @m $dMonad1 -> $fApplicativeHeapPrintT ($p1Monad $dMonad1)

$fMonadHeapPrintT
  = \ @t @m $dMonad1 ->
      C:Monad
        ($cp1Monad1 $dMonad1)
        ((\ @a @b -> ($fMonadReaderT_$c>>= $dMonad1))
         `cast` <Co:26> :: (forall {a} {b}.
                            ReaderT (HeapGraph t, IntMap String) m a
                            -> (a -> ReaderT (HeapGraph t, IntMap String) m b)
                            -> ReaderT (HeapGraph t, IntMap String) m b)
                           ~R# (forall {a} {b}.
                                HeapPrintT t m a -> (a -> HeapPrintT t m b) -> HeapPrintT t m b))
        ((\ @a @b -> ($fMonadReaderT_$c>> $dMonad1))
         `cast` <Co:23> :: (forall {a} {b}.
                            ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b
                            -> ReaderT (HeapGraph t, IntMap String) m b)
                           ~R# (forall {a} {b}.
                                HeapPrintT t m a -> HeapPrintT t m b -> HeapPrintT t m b))
        ((\ @a -> ($fMonadReaderT_$creturn $dMonad1))
         `cast` <Co:10> :: (forall {a}.
                            a -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a}. a -> HeapPrintT t m a))

$cp1MonadIO
  = \ @t @m $dMonadIO -> $fMonadHeapPrintT ($p1MonadIO $dMonadIO)

$fMonadIOHeapPrintT
  = \ @t @m $dMonadIO ->
      C:MonadIO
        ($cp1MonadIO $dMonadIO)
        ((\ @a -> ($fMonadIOReaderT_$cliftIO $dMonadIO))
         `cast` <Co:11> :: (forall {a}.
                            IO a -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a}. IO a -> HeapPrintT t m a))

$cp1MonadState
  = \ @s @t @m $dMonadState ->
      $fMonadHeapPrintT ($p1MonadState $dMonadState)

$fMonadStatesHeapPrintT
  = \ @s @t @m $dMonadState ->
      C:MonadState
        ($cp1MonadState $dMonadState)
        (($cget $dMonadState)
         `cast` <Co:5> :: ReaderT (HeapGraph t, IntMap String) m s
                          ~R# HeapPrintT t m s)
        (($cput $dMonadState)
         `cast` <Co:8> :: (s -> ReaderT (HeapGraph t, IntMap String) m ())
                          ~R# (s -> HeapPrintT t m ()))
        (($cstate $dMonadState)
         `cast` <Co:13> :: (forall {a}.
                            (s -> (a, s)) -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a}. (s -> (a, s)) -> HeapPrintT t m a))

$cp1MonadDecorate
  = \ @t @m $dMonadDecorate2 ->
      $fMonadHeapPrintT ($p1MonadDecorate $dMonadDecorate2)

$fMonadHeapPrinttHeapPrintT
  = \ @m @t $dMonad1 ->
      C:MonadHeapPrint
        ($fMonadHeapPrintT $dMonad1)
        (($cgetHeapBindings $dMonad1)
         `cast` <Co:17> :: ((HeapGraph t, IntMap String)
                            -> m (IntMap String))
                           ~R# HeapPrintT t m (IntMap String))
        (($cgetHeapContent $dMonad1)
         `cast` <Co:17> :: ((HeapGraph t, IntMap String) -> m (HeapGraph t))
                           ~R# HeapPrintT t m (HeapGraph t))

$dmgetHeapContent
  = \ @k @m _ @t @n $d~ $dMonadHeapPrint2 $dMonadTrans ->
      case eq_sel $d~ of co { __DEFAULT ->
      (($dMonadTrans
        `cast` <Co:2> :: MonadTrans t
                         ~R# (forall (m :: * -> *) a. Monad m => m a -> t m a))
         ($p1MonadHeapPrint $dMonadHeapPrint2)
         (getHeapContent $dMonadHeapPrint2))
      `cast` <Co:5> :: t n (HeapGraph k) ~R# m (HeapGraph k)
      }

$dmgetHeapBindings
  = \ @k @m _ @t @n $d~ $dMonadHeapPrint2 $dMonadTrans ->
      case eq_sel $d~ of co { __DEFAULT ->
      (($dMonadTrans
        `cast` <Co:2> :: MonadTrans t
                         ~R# (forall (m :: * -> *) a. Monad m => m a -> t m a))
         ($p1MonadHeapPrint $dMonadHeapPrint2)
         (getHeapBindings $dMonadHeapPrint2))
      `cast` <Co:5> :: t n (IntMap String) ~R# m (IntMap String)
      }

$fMonadHeapPrinttDecorateT
  = \ @t @m $dMonadHeapPrint1 ->
      C:MonadHeapPrint
        ($cp1MonadHeapPrint $dMonadHeapPrint1)
        ((\ _ -> getHeapBindings $dMonadHeapPrint1)
         `cast` <Co:13> :: (IntMap Attr -> m (IntMap String))
                           ~R# DecorateT m (IntMap String))
        ((\ _ -> getHeapContent $dMonadHeapPrint1)
         `cast` <Co:13> :: (IntMap Attr -> m (HeapGraph t))
                           ~R# DecorateT m (HeapGraph t))

$dmdecorateMap
  = \ @m _ @t @m' $dMonadTrans $dMonadDecorate3 $d~ ->
      case eq_sel $d~ of co { __DEFAULT ->
      (($dMonadTrans
        `cast` <Co:2> :: MonadTrans t
                         ~R# (forall (m :: * -> *) a. Monad m => m a -> t m a))
         ($p1MonadDecorate $dMonadDecorate3) (decorateMap $dMonadDecorate3))
      `cast` <Co:5> :: t m' (IntMap Attr) ~R# m (IntMap Attr)
      }

$fMonadDecorateHeapPrintT
  = \ @t @m $dMonadDecorate2 ->
      C:MonadDecorate
        ($cp1MonadDecorate $dMonadDecorate2)
        ((\ _ -> decorateMap $dMonadDecorate2)
         `cast` <Co:17> :: ((HeapGraph t, IntMap String) -> m (IntMap Attr))
                           ~R# HeapPrintT t m (IntMap Attr))

unDecorateT1 = \ @m @a ds -> ds

unDecorateT
  = unDecorateT1
    `cast` <Co:13> :: (forall {m :: * -> *} {a}.
                       DecorateT m a -> DecorateT m a)
                      ~R# (forall {m :: * -> *} {a}.
                           DecorateT m a -> ReaderT (IntMap Attr) m a)

unHeapPrintT1 = \ @t @m @a ds -> ds

unHeapPrintT
  = unHeapPrintT1
    `cast` <Co:17> :: (forall {t} {m :: * -> *} {a}.
                       HeapPrintT t m a -> HeapPrintT t m a)
                      ~R# (forall {t} {m :: * -> *} {a}.
                           HeapPrintT t m a -> ReaderT (HeapGraph t, IntMap String) m a)

traverseHeapGraph
  = \ @m @a @b $dApplicative1 eta eta1 ->
      fmap
        ($p1Applicative $dApplicative1)
        ((\ ds -> ds)
         `cast` <Co:8> :: (IntMap (HeapGraphEntry b)
                           -> IntMap (HeapGraphEntry b))
                          ~R# (IntMap (HeapGraphEntry b) -> HeapGraph b))
        (traverse
           $fTraversableIntMap
           $dApplicative1
           eta
           (eta1 `cast` <Co:2> :: HeapGraph a ~R# IntMap (HeapGraphEntry a)))

traverseHeapEntry
  = \ @m @a @b $dApplicative1 eta eta1 ->
      fmap
        ($p1Applicative $dApplicative1)
        (\ x ->
           case eta1 of { HeapGraphEntry ds ds1 ds2 ds3 ->
           HeapGraphEntry ds ds1 ds2 x
           })
        (eta (case eta1 of { HeapGraphEntry ds1 ds2 ds3 ds4 -> ds4 }))

childrenOf
  = \ @t i hg ->
      case lookup
             i (hg `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t))
      of {
        Nothing -> [];
        Just hge ->
          catMaybes
            (case hge of { HeapGraphEntry ds1 ds2 ds3 ds4 ->
             $fFoldableGenClosure_$cfoldr (\ ds ds7 -> : ds ds7) [] ds2
             })
      }

lookupDecorate
  = \ @m $dMonadDecorate2 ->
      let { $dFunctor = $p1MonadDecorate $dMonadDecorate2 } in
      let { $dFunctor1 = $p1Monad $dFunctor } in
      let { $dFunctor2 = $p1Applicative $dFunctor1 } in
      \ i -> fmap $dFunctor2 (lookup i) (decorateMap $dMonadDecorate2)

runDecorateT
  = runReaderT1
    `cast` <Co:16> :: (forall {m :: * -> *} {a}.
                       ReaderT (IntMap Attr) m a -> ReaderT (IntMap Attr) m a)
                      ~R# (forall {m :: * -> *} {a}. DecorateT m a -> IntMap Attr -> m a)

pClos1
  = \ @k @k1 @k2 @t @r @f @x @m $dIP4 $dPrintClosure34 a b ->
      pClosImpl
        $dPrintClosure34
        $dIP4
        (proxy# `cast` <Co:6> :: Proxy# x ~R# (?printLocal::Proxy# x))
        a
        b

pClos
  = pClos1
    `cast` <Co:50> :: (forall {k} {k1} {k2} {t :: k} {r :: k1} {f}
                              {x :: k2} {m :: * -> *}.
                       (?printBase::Proxy# r, PrintClosure r x f m) =>
                       Int -> f -> m (Doc Attr))
                      ~R# (forall {k} {k1} {k2} {t :: k} {r :: k1} {f} {x :: k2}
                                  {m :: * -> *}.
                           (?printBase::Proxy# r, PrintClosure r x f m) =>
                           Int -> f -> Dispatch t r x (m (Doc Attr)))

printClosure
  = \ @k @r @f @m $dPrintClosure34 prec f1 ->
      pClos1
        (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printBase::Proxy# r))
        $dPrintClosure34
        prec
        f1

$cpClosImpl1
  = \ @k @r @t @m $dPrintClosure34 $dMonadHeapPrint1 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec ds ->
        case ds of { HeapKV ds1 s t1 ->
        fmap
          $dFunctor
          (\ p ->
             Cat
               ($fIsStringDoc_$cfromString s)
               (Cat ($fIsStringDoc_$cfromString (unpackCString# " = "#)) p))
          (pClosImpl
             $dPrintClosure34
             $dIP4
             (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
             prec
             t1)
        }

$fPrintClosurekTYPErBaseHeapKVm
  = \ @k @r @t @m $dPrintClosure34 $dMonadHeapPrint1 ->
      C:PrintClosure
        ($cp1PrintClosure6 $dPrintClosure34 $dMonadHeapPrint1)
        ($cpClosImpl1 $dPrintClosure34 $dMonadHeapPrint1)

$fPrintClosurekTYPErDecorateElemsbm
  = \ @k @k1 @r @x @b @m $dPrintClosure34 $dMonadDecorate2 ->
      C:PrintClosure
        ($cp1PrintClosure2 $dPrintClosure34 $dMonadDecorate2)
        (\ $dIP4 _ prec idx -> pClos1 $dIP4 $dPrintClosure34 prec idx)

$cpClosImpl2
  = \ @k @k1 @r @x @m $dPrintClosure34 $dMonadDecorate2 ->
      let { $dMonad1 = $p1MonadDecorate $dMonadDecorate2 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec idx ->
        >>=
          $dMonad1
          (lookupDecorate $dMonadDecorate2 idx)
          (\ ds ->
             case ds of {
               Nothing -> pClos1 $dIP4 $dPrintClosure34 prec idx;
               Just dec ->
                 fmap
                   $dFunctor
                   (\ ds1 -> Annotated dec ds1)
                   (pClosImpl
                      $dPrintClosure34
                      $dIP4
                      (proxy# `cast` <Co:6> :: Proxy# x ~R# (?printLocal::Proxy# x))
                      prec
                      idx)
             })

$fPrintClosurekTYPErDecorateElemsIntm
  = \ @k @k1 @r @x @m $dPrintClosure34 $dMonadDecorate2 ->
      C:PrintClosure
        ($cp1PrintClosure1 $dPrintClosure34 $dMonadDecorate2)
        ($cpClosImpl2 $dPrintClosure34 $dMonadDecorate2)

$cpClosImpl3
  = \ @k @k1 @m @r @f @t $dMonadDecorate2 $dPrintClosure34 ->
      let { $dMonad1 = $p1MonadDecorate $dMonadDecorate2 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec v ->
        case v of wild { HeapKV idx ds ds1 ->
        >>=
          $dMonad1
          (lookupDecorate $dMonadDecorate2 idx)
          (\ ds2 ->
             case ds2 of {
               Nothing ->
                 pClosImpl
                   $dPrintClosure34
                   $dIP4
                   (proxy# `cast` <Co:6> :: Proxy# f ~R# (?printLocal::Proxy# f))
                   prec
                   wild;
               Just dec ->
                 fmap
                   $dFunctor
                   (\ ds3 -> Annotated dec ds3)
                   (pClosImpl
                      $dPrintClosure34
                      $dIP4
                      (proxy# `cast` <Co:6> :: Proxy# f ~R# (?printLocal::Proxy# f))
                      prec
                      wild)
             })
        }

$fPrintClosurekTYPErDecorateElemsHeapKVm
  = \ @k @k1 @m @r @f @t $dMonadDecorate2 $dPrintClosure34 ->
      C:PrintClosure
        ($cp1PrintClosure $dMonadDecorate2 $dPrintClosure34)
        ($cpClosImpl3 $dMonadDecorate2 $dPrintClosure34)

$fPrintClosurekTYPErElidesm
  = \ @k @k1 @k2 @r @f @s @m @t $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        (\ $dIP4 _ prec c -> pClos1 $dIP4 $dPrintClosure34 prec c)

$fPrintClosurekTYPErPrettyTextbm
  = \ @k @k1 @r @f @b @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        (\ $dIP4 _ p f1 -> pClos1 $dIP4 $dPrintClosure34 p f1)

$fPrintClosurekTYPErPrettyListLiteralsbm
  = \ @k @k1 @r @f @b @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        (\ $dIP4 _ p f1 -> pClos1 $dIP4 $dPrintClosure34 p f1)

$cpClosImpl4
  = \ @k @r @x @m $dPrintClosure34 eta _ eta2 eta3 ->
      case eta3 of {
        Nothing ->
          pure
            ($p1PrintClosure $dPrintClosure34)
            ($fIsStringDoc_$cfromString (unpackCString# "..."#));
        Just i -> pClos1 eta $dPrintClosure34 eta2 i
      }

$fPrintClosurekTYPErBaseMaybem
  = \ @k @r @x @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34) ($cpClosImpl4 $dPrintClosure34)

$cpClosImpl5
  = \ @k @r @m $dPrintClosure34 $dIP4 _ prec hge ->
      pClosImpl
        $dPrintClosure34
        $dIP4
        (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
        prec
        (case hge of { HeapGraphEntry ds1 ds2 ds3 ds4 -> ds2 })

$fPrintClosurekTYPErBaseHeapGraphEntrym
  = \ @k @r @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34) ($cpClosImpl5 $dPrintClosure34)

$fPrintClosurekTYPErNamedThunksbm
  = \ @k @k1 @r @f @b @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        (\ $dIP4 _ p f1 -> pClos1 $dIP4 $dPrintClosure34 p f1)

isNil
  = \ @b ds ->
      case ds of {
        __DEFAULT -> False;
        ConstrClosure ds1 ds2 ds3 ds4 ds5 ds6 ->
          case eqString ds6 (unpackCString# "[]"#) of {
            False -> False;
            True ->
              case ds3 of {
                [] ->
                  case ds2 of {
                    [] -> True;
                    : ipv ipv1 -> False
                  };
                : ipv ipv1 -> False
              }
          }
      }

addBraces
  = \ @s $dMonoid $dIsString eta eta1 ->
      let { $dSemigroup = $p1Monoid $dMonoid } in
      case eta of {
        False -> eta1;
        True ->
          <>
            $dSemigroup
            (($dIsString `cast` <Co:2> :: IsString s ~R# (String -> s))
               (unpackCString# "("#))
            (<>
               $dSemigroup
               eta1
               (($dIsString `cast` <Co:2> :: IsString s ~R# (String -> s))
                  (unpackCString# ")"#)))
      }

app
  = \ @ann ds ds1 ->
      join {
        fail _
          = case ds of { I# y ->
            case tagToEnum# (<=# 10# y) of {
              False -> sep ds1;
              True ->
                Cat
                  ($fIsStringDoc_$cfromString (unpackCString# "("#))
                  (Cat (sep ds1) ($fIsStringDoc_$cfromString (unpackCString# ")"#)))
            }
            } } in
      case ds1 of {
        [] -> jump fail (##);
        : a ds2 ->
          case ds2 of {
            [] -> Cat a ($fIsStringDoc_$cfromString (unpackCString# "()"#));
            : ipv ipv1 -> jump fail (##)
          }
      }

$cpClosImpl6
  = \ @k @k1 @r @m @f $dPrintClosure34 $dPrintClosure35 ->
      let { $dApplicative1 = $p1PrintClosure $dPrintClosure34 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec hge ->
        case hge of wild { HeapGraphEntry ds1 ds2 ds3 ds4 ->
        case ds2 of {
          __DEFAULT ->
            pClosImpl
              $dPrintClosure35
              $dIP4
              (proxy# `cast` <Co:6> :: Proxy# f ~R# (?printLocal::Proxy# f))
              prec
              wild;
          FunClosure ds ds7 ds8 ->
            case ds4 of { HeapData ds9 ds10 ->
            case ds9 of {
              Nothing ->
                pClosImpl
                  $dPrintClosure35
                  $dIP4
                  (proxy# `cast` <Co:6> :: Proxy# f ~R# (?printLocal::Proxy# f))
                  prec
                  wild;
              Just ds11 ->
                case ds11 of { From ds12 ds13 ds14 ds15 ds16 ds17 ->
                fmap
                  $dFunctor
                  (\ ptrs ->
                     app
                       prec
                       (: (viaShow_$cpretty ds12)
                          (++ ptrs (map $fPrettyWord_$cpretty ds8))))
                  (traverse
                     $fTraversable[]
                     $dApplicative1
                     (let { a = I# 10# } in
                      \ x ->
                        pClosImpl
                          $dPrintClosure34
                          $dIP4
                          (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                          a
                          x)
                     ds7)
                }
            }
            };
          ThunkClosure ds ds7 ds8 ->
            case ds4 of { HeapData ds9 ds10 ->
            case ds9 of {
              Nothing ->
                pClosImpl
                  $dPrintClosure35
                  $dIP4
                  (proxy# `cast` <Co:6> :: Proxy# f ~R# (?printLocal::Proxy# f))
                  prec
                  wild;
              Just ds11 ->
                case ds11 of { From ds12 ds13 ds14 ds15 ds16 ds17 ->
                fmap
                  $dFunctor
                  (\ ptrs ->
                     app
                       prec
                       (: (viaShow_$cpretty ds12)
                          (++ ptrs (map $fPrettyWord_$cpretty ds8))))
                  (traverse
                     $fTraversable[]
                     $dApplicative1
                     (let { a = I# 10# } in
                      \ x ->
                        pClosImpl
                          $dPrintClosure34
                          $dIP4
                          (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                          a
                          x)
                     ds7)
                }
            }
            }
        }
        }

$fPrintClosurekTYPErNamedThunksHeapGraphEntrym
  = \ @k @k1 @r @m @f $dPrintClosure34 $dPrintClosure35 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        ($cpClosImpl6 $dPrintClosure34 $dPrintClosure35)

braceize
  = \ @a ds ->
      case ds of wild {
        [] -> $fIsStringDoc_$cfromString [];
        : ipv ipv1 ->
          braces
            (case punctuate comma wild of {
               [] -> Empty;
               : ds1 ds2 ->
                 case ds2 of {
                   [] -> ds1;
                   : ipv2 ipv3 -> Cat ds1 (Cat line1 (hsep1 ipv2 ipv3))
                 }
             })
      }

$dIP
  = pushCallStack
      (unpackCString# "tail"#,
       SrcLoc
         (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
         (unpackCString# "HeapUtils"#)
         (unpackCString# "src/HeapUtils.hs"#)
         (I# 312#)
         (I# 21#)
         (I# 312#)
         (I# 25#))
      emptyCallStack

$dIP1
  = pushCallStack
      (unpackCString# "last"#,
       SrcLoc
         (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
         (unpackCString# "HeapUtils"#)
         (unpackCString# "src/HeapUtils.hs"#)
         (I# 311#)
         (I# 28#)
         (I# 311#)
         (I# 32#))
      emptyCallStack

$dIP2
  = pushCallStack
      (unpackCString# "head"#,
       SrcLoc
         (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
         (unpackCString# "HeapUtils"#)
         (unpackCString# "src/HeapUtils.hs"#)
         (I# 311#)
         (I# 8#)
         (I# 311#)
         (I# 12#))
      emptyCallStack

isTup
  = \ @b ds ->
      case ds of {
        __DEFAULT -> Nothing;
        ConstrClosure ds1 ds2 ds3 ds4 ds5 ds6 ->
          case ds3 of {
            [] ->
              case $wlenAcc ds6 0# of ww { __DEFAULT ->
              case tagToEnum# (>=# ww 3#) of {
                False -> Nothing;
                True ->
                  case ds6 of wild3 {
                    [] ->
                      case head1
                             ($dIP2 `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
                      of wild4 {
                      };
                    : x ds7 ->
                      case x of wild4 { C# x1 ->
                      case x1 of {
                        __DEFAULT -> Nothing;
                        '('# ->
                          letrec {
                            go1
                              = \ ds8 eta ->
                                  case ds8 of {
                                    [] -> eta;
                                    : y ys -> go1 ys y
                                  }; } in
                          case go1
                                 wild3
                                 (case $dIP1 of wild6 {
                                    __DEFAULT ->
                                      lastError
                                        ((PushCallStack
                                            (unpackFoldrCString#
                                               "lastError"# (\ ds8 ds9 -> : ds8 ds9) [])
                                            (SrcLoc
                                               (unpackFoldrCString#
                                                  "base"# (\ ds8 ds9 -> : ds8 ds9) [])
                                               (unpackFoldrCString#
                                                  "GHC.List"# (\ ds8 ds9 -> : ds8 ds9) [])
                                               (unpackFoldrCString#
                                                  "libraries/base/GHC/List.hs"#
                                                  (\ ds8 ds9 -> : ds8 ds9)
                                                  [])
                                               (I# 151#)
                                               (I# 29#)
                                               (I# 151#)
                                               (I# 38#))
                                            wild6)
                                         `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack));
                                    FreezeCallStack ds8 ->
                                      lastError
                                        (wild6
                                         `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
                                  })
                          of
                          { C# x2 ->
                          case x2 of {
                            __DEFAULT -> Nothing;
                            ')'# ->
                              letrec {
                                go2
                                  = \ ds8 ->
                                      case ds8 of {
                                        [] -> True `cast` <Co:2> :: Bool ~R# All;
                                        : y ys ->
                                          case y `cast` <Co:1> :: All ~R# Bool of {
                                            False -> False `cast` <Co:2> :: Bool ~R# All;
                                            True -> go2 ys
                                          }
                                      }; } in
                              case (go2
                                      (letrec {
                                         go3
                                           = \ ds8 ->
                                               case ds8 of {
                                                 [] -> [];
                                                 : y ys ->
                                                   : (case y of { C# x3 ->
                                                      case x3 of {
                                                        __DEFAULT ->
                                                          False `cast` <Co:2> :: Bool ~R# All;
                                                        ','# -> True `cast` <Co:2> :: Bool ~R# All
                                                      }
                                                      })
                                                     (go3 ys)
                                               }; } in
                                       go3
                                         (case init1 wild4 ds7 of {
                                            [] ->
                                              lvl
                                                ($dIP
                                                 `cast` <Co:4> :: CallStack
                                                                  ~R# (?callStack::CallStack));
                                            : ds8 xs -> xs
                                          })))
                                   `cast` <Co:1> :: All ~R# Bool
                              of {
                                False -> Nothing;
                                True -> Just ds2
                              }
                          }
                          }
                      }
                      }
                  }
              }
              };
            : ipv ipv1 -> Nothing
          }
      }

$cpClosImpl7
  = \ @k @r @b @m $dPrintClosure34 ->
      let { $dApplicative1 = $p1PrintClosure $dPrintClosure34 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec c ->
        let {
          shorten
            = \ @a $dIsString xs ->
                case $wlenAcc xs 0# of ww { __DEFAULT ->
                case tagToEnum# (># ww 20#) of {
                  False -> xs;
                  True ->
                    ++
                      ($wunsafeTake 20# xs)
                      (: (($dIsString `cast` <Co:2> :: IsString a ~R# (String -> a))
                            (unpackCString# "(and more)"#))
                         [])
                }
                } } in
        join {
          appBox str sel
            = fmap
                $dFunctor
                (\ s -> app prec (: str (: s [])))
                (pClosImpl
                   $dPrintClosure34
                   $dIP4
                   (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                   (I# 10#)
                   sel) } in
        case isChar c of {
          Nothing ->
            case isCons c of {
              Nothing ->
                case isTup c of {
                  Nothing ->
                    case c of {
                      ConstrClosure ds ds1 ds2 ds3 ds4 ds5 ->
                        fmap
                          $dFunctor
                          (\ ptrs ->
                             app
                               prec
                               (: ($fIsStringDoc_$cfromString ds5)
                                  (++ ptrs (map $fPrettyWord_$cpretty ds2))))
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              \ v' ->
                                pClosImpl
                                  $dPrintClosure34
                                  $dIP4
                                  (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                  i'
                                  v')
                             ds1);
                      FunClosure ds ds1 ds2 ->
                        fmap
                          $dFunctor
                          (\ ptrs ->
                             Cat
                               ($fIsStringDoc_$cfromString (unpackCString# "_fun"#))
                               (braceize (++ ptrs (map $fPrettyWord_$cpretty ds2))))
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 0# } in
                              \ v' ->
                                pClosImpl
                                  $dPrintClosure34
                                  $dIP4
                                  (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                  i'
                                  v')
                             ds1);
                      ThunkClosure ds ds1 ds2 ->
                        fmap
                          $dFunctor
                          (\ ptrs ->
                             app
                               prec
                               (: ($fIsStringDoc_$cfromString (unpackCString# "_thunk"#))
                                  (++ ptrs (map $fPrettyWord_$cpretty ds2))))
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              \ v' ->
                                pClosImpl
                                  $dPrintClosure34
                                  $dIP4
                                  (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                  i'
                                  v')
                             ds1);
                      SelectorClosure ds ds1 ->
                        jump appBox
                          ($fIsStringDoc_$cfromString (unpackCString# "_sel"#)) ds1;
                      PAPClosure ds bx bx1 ds1 ds2 ->
                        fmap
                          $dFunctor
                          (app prec)
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              \ v' ->
                                pClosImpl
                                  $dPrintClosure34
                                  $dIP4
                                  (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                  i'
                                  v')
                             (: ds1 ds2));
                      APClosure ds bx bx1 ds1 ds2 ->
                        fmap
                          $dFunctor
                          (app prec)
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              \ v' ->
                                pClosImpl
                                  $dPrintClosure34
                                  $dIP4
                                  (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                  i'
                                  v')
                             (: ds1 ds2));
                      APStackClosure ds ds1 ds2 ->
                        fmap
                          $dFunctor
                          (app prec)
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              \ v' ->
                                pClosImpl
                                  $dPrintClosure34
                                  $dIP4
                                  (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                  i'
                                  v')
                             (: ds1 ds2));
                      IndClosure ds ds1 ->
                        jump appBox
                          ($fIsStringDoc_$cfromString (unpackCString# "_ind"#)) ds1;
                      BCOClosure ds ds1 ds2 ds3 bx bx1 ds4 ->
                        jump appBox
                          ($fIsStringDoc_$cfromString (unpackCString# "_bco"#)) ds3;
                      BlackholeClosure ds ds1 ->
                        jump appBox
                          ($fIsStringDoc_$cfromString (unpackCString# "_bh"#)) ds1;
                      ArrWordsClosure ds bx ds1 ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: ($fIsStringDoc_$cfromString (unpackCString# "toArray"#))
                                (: (Cat
                                      ($fIsStringDoc_$cfromString (unpackCString# "("#))
                                      (Cat
                                         (case $wlenAcc ds1 0# of ww { __DEFAULT ->
                                          $w$cpretty2 ww
                                          })
                                         ($fIsStringDoc_$cfromString (unpackCString# " words)"#))))
                                   (: (sep
                                         (punctuate
                                            comma
                                            (shorten
                                               ($fIsStringDoc_$cfromString
                                                `cast` <Co:4> :: (String -> Doc Attr)
                                                                 ~R# IsString (Doc Attr))
                                               (map $fPrettyWord_$cpretty ds1))))
                                      []))));
                      MutArrClosure ds bx bx1 ds1 ->
                        fmap
                          $dFunctor
                          (\ payload ->
                             group
                               (encloseSep
                                  $dmprettyList8
                                  $dmprettyList3
                                  $dmprettyList1
                                  (shorten
                                     ($fIsStringDoc_$cfromString
                                      `cast` <Co:4> :: (String -> Doc Attr) ~R# IsString (Doc Attr))
                                     payload)))
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              \ v' ->
                                pClosImpl
                                  $dPrintClosure34
                                  $dIP4
                                  (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                  i'
                                  v')
                             ds1);
                      SmallMutArrClosure ds bx ds1 ->
                        fmap
                          $dFunctor
                          (\ payload ->
                             group
                               (encloseSep
                                  $dmprettyList8
                                  $dmprettyList3
                                  $dmprettyList1
                                  (shorten
                                     ($fIsStringDoc_$cfromString
                                      `cast` <Co:4> :: (String -> Doc Attr) ~R# IsString (Doc Attr))
                                     payload)))
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              \ v' ->
                                pClosImpl
                                  $dPrintClosure34
                                  $dIP4
                                  (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                  i'
                                  v')
                             ds1);
                      MVarClosure ds ds1 ds2 ds3 ->
                        jump appBox
                          ($fIsStringDoc_$cfromString (unpackCString# "MVar"#)) ds3;
                      IOPortClosure ds ds1 ds2 ds3 ->
                        pure
                          $dApplicative1
                          ($fIsStringDoc_$cfromString (unpackCString# "_ioPortClosure"#));
                      MutVarClosure ds ds1 ->
                        jump appBox
                          ($fIsStringDoc_$cfromString (unpackCString# "_mutVar"#)) ds1;
                      BlockingQueueClosure ds ds1 ds2 ds3 ds4 ->
                        pure
                          $dApplicative1
                          ($fIsStringDoc_$cfromString (unpackCString# "_blockingQueue"#));
                      WeakClosure ds ds1 ds2 ds3 ds4 ds5 ->
                        pure
                          $dApplicative1
                          ($fIsStringDoc_$cfromString (unpackCString# "_weak"#));
                      TSOClosure ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 bx bx1 bx2 bx3
                                 bx4 ds10 ->
                        pure
                          $dApplicative1
                          ($fIsStringDoc_$cfromString (unpackCString# "_tsoClosure"#));
                      StackClosure ds bx bx1 bx2 ->
                        pure
                          $dApplicative1
                          ($fIsStringDoc_$cfromString (unpackCString# "_stackClosure"#));
                      IntClosure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: ($fIsStringDoc_$cfromString (unpackCString# "Int"#))
                                (: ($w$cpretty2 bx) [])));
                      WordClosure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: ($fIsStringDoc_$cfromString (unpackCString# "Word"#))
                                (: ($w$cpretty7 bx) [])));
                      Int64Closure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: ($fIsStringDoc_$cfromString (unpackCString# "Int64"#))
                                (: ($w$cpretty5 bx) [])));
                      Word64Closure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: ($fIsStringDoc_$cfromString (unpackCString# "Word64"#))
                                (: ($w$cpretty10 bx) [])));
                      AddrClosure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: ($fIsStringDoc_$cfromString (unpackCString# "Addr"#))
                                (: ($w$cpretty2 bx) [])));
                      FloatClosure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: ($fIsStringDoc_$cfromString (unpackCString# "Float"#))
                                (: ($fPrettyFloat_$cpretty (F# bx)) [])));
                      DoubleClosure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: ($fIsStringDoc_$cfromString (unpackCString# "Double"#))
                                (: ($fPrettyDouble_$cpretty (D# bx)) [])));
                      OtherClosure ds ds1 ds2 ->
                        pure
                          $dApplicative1
                          ($fIsStringDoc_$cfromString (unpackCString# "_other"#));
                      UnsupportedClosure ds ->
                        pure
                          $dApplicative1
                          ($fIsStringDoc_$cfromString
                             (unpackCString# "_unsupported closure"#))
                    };
                  Just vs ->
                    fmap
                      $dFunctor
                      tupled
                      (traverse
                         $fTraversable[]
                         $dApplicative1
                         (let { i' = I# 1# } in
                          \ v' ->
                            pClosImpl
                              $dPrintClosure34
                              $dIP4
                              (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                              i'
                              v')
                         vs)
                };
              Just ds ->
                case ds of { (h, t) ->
                fmap
                  $dFunctor
                  (let { eta = case prec of { I# y -> tagToEnum# (<=# 5# y) } } in
                   \ eta1 ->
                     case eta of {
                       False -> eta1;
                       True ->
                         Cat
                           ($fIsStringDoc_$cfromString (unpackCString# "("#))
                           (Cat eta1 ($fIsStringDoc_$cfromString (unpackCString# ")"#)))
                     })
                  (<*>
                     $dApplicative1
                     (fmap
                        $dFunctor
                        (\ l r1 ->
                           Cat
                             l (Cat ($fIsStringDoc_$cfromString (unpackCString# " : "#)) r1))
                        (pClosImpl
                           $dPrintClosure34
                           $dIP4
                           (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                           (I# 5#)
                           h))
                     (pClosImpl
                        $dPrintClosure34
                        $dIP4
                        (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                        (I# 4#)
                        t))
                }
            };
          Just ch ->
            pure
              $dApplicative1
              (app
                 prec
                 (: ($fIsStringDoc_$cfromString (unpackCString# "C#"#))
                    (: (case ch of { C# ds1 ->
                        case ds1 of ds2 {
                          __DEFAULT -> Char ds2;
                          '\n'# -> line
                        }
                        })
                       [])))
        }

$fPrintClosurekTYPErBaseGenClosurem
  = \ @k @r @b @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34) ($cpClosImpl7 $dPrintClosure34)

lookupBindingLabel
  = \ @t @m $dMonadHeapPrint1 ->
      let { $dFunctor = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dFunctor1 = $p1Monad $dFunctor } in
      let { $dFunctor2 = $p1Applicative $dFunctor1 } in
      \ i ->
        fmap $dFunctor2 (lookup i) (getHeapBindings $dMonadHeapPrint1)

lookupHeapClosure
  = \ @t @m $dMonadHeapPrint1 ->
      let {
        $dIP4
          = pushCallStack
              (unpackCString# "fromJust"#,
               SrcLoc
                 (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
                 (unpackCString# "HeapUtils"#)
                 (unpackCString# "src/HeapUtils.hs"#)
                 (I# 339#)
                 (I# 23#)
                 (I# 339#)
                 (I# 31#))
              emptyCallStack } in
      let { $dFunctor = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dFunctor1 = $p1Monad $dFunctor } in
      let { $dFunctor2 = $p1Applicative $dFunctor1 } in
      \ i ->
        fmap
          $dFunctor2
          (let {
             f = fromJust
                   ($dIP4 `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack)) } in
           \ x ->
             f (lookup
                  i (x `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t))))
          (getHeapContent $dMonadHeapPrint1)

lookupHeapRep
  = \ @t @m $dMonadHeapPrint1 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ i ->
        >>=
          $dMonad1
          (lookupBindingLabel $dMonadHeapPrint1 i)
          (\ ds ->
             case ds of {
               Nothing ->
                 fmap
                   $dFunctor
                   (\ ds1 -> Right ds1)
                   (lookupHeapClosure $dMonadHeapPrint1 i);
               Just o -> pure $dApplicative1 (Left o)
             })

$cpClosImpl8
  = \ @k @b @m @r $dMonadHeapPrint1 $dPrintClosure34 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      \ $dIP4 _ r1 i ->
        >>=
          $dMonad1
          (lookupHeapRep $dMonadHeapPrint1 i)
          (\ ds ->
             case ds of {
               Left l -> pure $dApplicative1 ($fIsStringDoc_$cfromString l);
               Right e -> pClos1 $dIP4 $dPrintClosure34 r1 e
             })

$fPrintClosurekTYPErBaseIntm
  = \ @k @b @m @r $dMonadHeapPrint1 $dPrintClosure34 ->
      C:PrintClosure
        ($cp1PrintClosure3 $dMonadHeapPrint1 $dPrintClosure34)
        ($cpClosImpl8 $dMonadHeapPrint1 $dPrintClosure34)

heapIsBound
  = \ @t @m $dMonadHeapPrint1 ->
      let { $dFunctor = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dFunctor1 = $p1Monad $dFunctor } in
      let { $dFunctor2 = $p1Applicative $dFunctor1 } in
      \ i ->
        fmap $dFunctor2 (member i) (getHeapBindings $dMonadHeapPrint1)

lookupHeapUnbound
  = \ @t @m $dMonadHeapPrint1 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ i ->
        >>=
          $dMonad1
          (heapIsBound $dMonadHeapPrint1 i)
          (\ ds ->
             case ds of {
               False ->
                 fmap
                   $dFunctor
                   (\ ds1 ->
                      lookup
                        i (ds1 `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t)))
                   (getHeapContent $dMonadHeapPrint1);
               True -> pure $dApplicative1 Nothing
             })

$cpClosImpl9
  = \ @k @k1 @b @m @r @f $dMonadHeapPrint1 $dPrintClosure34 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      \ $dIP4 _ prec hge0 ->
        >>=
          $dMonad1
          (>>=
             $dMonad1
             (case hge0 of { HeapGraphEntry ds1 ds2 ds3 ds4 ->
              case ds2 of {
                __DEFAULT -> return $dMonad1 Nothing;
                ConstrClosure ds ds7 ds8 ds9 ds10 ds11 ->
                  case eqString ds11 (unpackCString# "Text"#) of {
                    False -> return $dMonad1 Nothing;
                    True ->
                      case ds8 of {
                        [] -> return $dMonad1 Nothing;
                        : len ds12 ->
                          case ds12 of {
                            [] -> return $dMonad1 Nothing;
                            : offs ds13 ->
                              case ds13 of {
                                [] ->
                                  case ds7 of {
                                    [] -> return $dMonad1 Nothing;
                                    : p ds14 ->
                                      case ds14 of {
                                        [] -> return $dMonad1 (Just (len, offs, p));
                                        : ipv ipv1 -> return $dMonad1 Nothing
                                      }
                                  };
                                : ipv ipv1 -> return $dMonad1 Nothing
                              }
                          }
                      }
                  }
              }
              })
             (\ v ->
                case v of {
                  Nothing -> return $dMonad1 Nothing;
                  Just y ->
                    case y of { (len, offs, ds) ->
                    case ds of {
                      Nothing -> return $dMonad1 Nothing;
                      Just p ->
                        >>=
                          $dMonad1
                          (lookupHeapUnbound $dMonadHeapPrint1 p)
                          (\ v1 ->
                             case v1 of {
                               Nothing -> return $dMonad1 Nothing;
                               Just y1 ->
                                 case y1 of { HeapGraphEntry ds1 ds2 ds3 ds4 ->
                                 case ds2 of {
                                   __DEFAULT -> return $dMonad1 Nothing;
                                   ArrWordsClosure ds5 bx ds6 ->
                                     return
                                       $dMonad1
                                       (Just
                                          (case unsafeCoerce ds1 of { ByteArray unbx ->
                                           case fromIntegral $fIntegralWord $fNumInt len of
                                           { I# unbx1 ->
                                           case fromIntegral $fIntegralWord $fNumInt offs of
                                           { I# unbx2 ->
                                           Text unbx unbx1 unbx2
                                           }
                                           }
                                           }))
                                 }
                                 }
                             })
                    }
                    }
                }))
          (\ ds ->
             case ds of {
               Nothing -> pClos1 $dIP4 $dPrintClosure34 prec hge0;
               Just s ->
                 pure
                   $dApplicative1 ($fIsStringDoc_$cfromString ($fShowText_$cshow s))
             })

$fPrintClosurekTYPErPrettyTextHeapGraphEntrym
  = \ @k @k1 @b @m @r @f $dMonadHeapPrint1 $dPrintClosure34 ->
      C:PrintClosure
        ($cp1PrintClosure4 $dMonadHeapPrint1 $dPrintClosure34)
        ($cpClosImpl9 $dMonadHeapPrint1 $dPrintClosure34)

(!!!)
  = \ @v $dIP4 ->
      let {
        $dIP5
          = pushCallStack
              (unpackCString# "error"#,
               SrcLoc
                 (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
                 (unpackCString# "HeapUtils"#)
                 (unpackCString# "src/HeapUtils.hs"#)
                 (I# 374#)
                 (I# 16#)
                 (I# 374#)
                 (I# 21#))
              ($dIP4 `cast` <Co:3> :: (?callStack::CallStack) ~R# CallStack) } in
      \ m k ->
        case lookup k m of {
          Nothing ->
            error
              ($dIP5 `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
              (++
                 (unpackCString# "HeapGraph.!!!: key "#)
                 (case k of { I# n ->
                  ++ (itos n []) (unpackCString# " not found"#)
                  }));
          Just v1 -> v1
        }

$dIP3
  = pushCallStack
      (unpackCString# "!!!"#,
       SrcLoc
         (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
         (unpackCString# "HeapUtils"#)
         (unpackCString# "src/HeapUtils.hs"#)
         (I# 370#)
         (I# 16#)
         (I# 370#)
         (I# 19#))
      emptyCallStack

mkBindingMap
  = \ @t ds ->
      fromList
        (letrec {
           ds1
             = \ ds2 ->
                 case ds2 of {
                   [] -> [];
                   : ds4 ds5 ->
                     case ds4 of { (k, vs) ->
                     letrec {
                       ds6
                         = \ ds7 ->
                             case ds7 of {
                               [] -> ds1 ds5;
                               : ds9 ds10 ->
                                 case ds9 of { (v, idx) ->
                                 : (v, : k ($fShowInt_$cshow idx)) (ds6 ds10)
                                 }
                             }; } in
                     ds6 (zip vs (enumFrom $fEnumInt (I# 1#)))
                     }
                 }; } in
         ds1
           (letrec {
              ds2
                = \ ds3 ->
                    case ds3 of {
                      [] -> [];
                      : ds5 ds6 ->
                        : (case !!!
                                  ($dIP3 `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
                                  (ds `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t))
                                  ds5
                           of
                           { HeapGraphEntry ds7 ds8 ds9 ds10 ->
                           case ds8 of {
                             __DEFAULT -> C# 'x'#;
                             FunClosure ds11 ds12 ds13 -> C# 'f'#;
                             ThunkClosure ds11 ds12 ds13 -> C# 't'#;
                             SelectorClosure ds11 ds12 -> C# 't'#;
                             PAPClosure ds11 bx bx1 ds12 ds13 -> C# 'f'#;
                             APClosure ds11 bx bx1 ds12 ds13 -> C# 't'#;
                             BCOClosure ds11 ds12 ds13 ds14 bx bx1 ds15 -> C# 't'#
                           }
                           },
                           : ds5 [])
                          (ds2 ds6)
                    }; } in
            toAscList1
              []
              (fromListWithKey
                 $fOrdChar
                 (\ _ x y -> ++ x y)
                 (ds2
                    (nubOrd
                       $fOrdInt
                       (: (I# 0#)
                          (let { v = > $fOrdInteger } in
                           let { v1 = IS 1# } in
                           letrec {
                             go1
                               = \ ds3 ->
                                   case ds3 of {
                                     [] -> [];
                                     : y ys ->
                                       let { z = go1 ys } in
                                       letrec {
                                         go2
                                           = \ ds4 ->
                                               case ds4 of {
                                                 [] -> z;
                                                 : y1 ys1 -> : y1 (go2 ys1)
                                               }; } in
                                       go2
                                         (catMaybes
                                            (case y of { HeapGraphEntry ds4 ds5 ds6 ds7 ->
                                             allClosures ds5
                                             }))
                                   }; } in
                           keys1
                             []
                             (filterWithKey
                                (\ _ x -> v x v1)
                                (fromListWithKey
                                   $fOrdInt
                                   (\ _ x y -> integerAdd x y)
                                   (map
                                      (\ ds3 -> (ds3, IS 1#))
                                      (go1
                                         (elems
                                            (ds
                                             `cast` <Co:2> :: HeapGraph t
                                                              ~R# IntMap
                                                                    (HeapGraphEntry t))))))))))))))

runHeapPrintT
  = \ @t @m @a ds hg ->
      (ds
       `cast` <Co:13> :: HeapPrintT t m a
                         ~R# ((HeapGraph t, IntMap String) -> m a))
        (hg, mkBindingMap hg)

$cpClosImpl10
  = \ @k @r @t @m $dPrintClosure34 $dMonadHeapPrint1 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      \ $dIP4 _ ->
        let {
          $dIP6
            = pushCallStack
                (unpackCString# "!!!"#,
                 SrcLoc
                   (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
                   (unpackCString# "HeapUtils"#)
                   (unpackCString# "src/HeapUtils.hs"#)
                   (I# 244#)
                   (I# 82#)
                   (I# 244#)
                   (I# 85#))
                emptyCallStack } in
        let {
          $dIP7
            = pushCallStack
                (unpackCString# "!!!"#,
                 SrcLoc
                   (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
                   (unpackCString# "HeapUtils"#)
                   (unpackCString# "src/HeapUtils.hs"#)
                   (I# 241#)
                   (I# 59#)
                   (I# 241#)
                   (I# 62#))
                emptyCallStack } in
        let {
          $dIP8
            = pushCallStack
                (unpackCString# "!!!"#,
                 SrcLoc
                   (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
                   (unpackCString# "HeapUtils"#)
                   (unpackCString# "src/HeapUtils.hs"#)
                   (I# 241#)
                   (I# 45#)
                   (I# 241#)
                   (I# 48#))
                emptyCallStack } in
        \ _ ds ->
          case ds of { HeapRoot r1 ->
          >>=
            $dMonad1
            (getHeapBindings $dMonadHeapPrint1)
            (\ binds ->
               >>=
                 $dMonad1
                 (getHeapContent $dMonadHeapPrint1)
                 (\ ds1 ->
                    >>=
                      $dMonad1
                      (forM
                         $fTraversable[]
                         $dMonad1
                         (: r1
                            (filter
                               (\ v -> member v binds)
                               (keys
                                  (ds1
                                   `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t)))))
                         (\ k1 ->
                            pClosImpl
                              $dPrintClosure34
                              $dIP4
                              (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                              (I# 0#)
                              (HeapKV
                                 k1
                                 (!!!
                                    ($dIP8 `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
                                    binds
                                    k1)
                                 (!!!
                                    ($dIP7 `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
                                    (ds1 `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t))
                                    k1))))
                      (\ kv ->
                         case member r1 binds of {
                           False ->
                             pure
                               $dApplicative1
                               ($fIsStringDoc_$cfromString (unpackCString# "???"#));
                           True ->
                             pure
                               $dApplicative1
                               (Cat
                                  ($fIsStringDoc_$cfromString (unpackCString# "let"#))
                                  (Cat
                                     line1
                                     (Cat
                                        (let {
                                           d = case kv of {
                                                 [] -> Empty;
                                                 : ds2 ds3 ->
                                                   case ds3 of {
                                                     [] -> ds2;
                                                     : ipv ipv1 ->
                                                       Cat ds2 (Cat line' (cat1 ipv ipv1))
                                                   }
                                               } } in
                                         Column
                                           (\ k1 ->
                                              Nesting
                                                (\ i ->
                                                   case k1 of { I# x ->
                                                   case i of { I# y ->
                                                   case -# x y of ds2 {
                                                     __DEFAULT -> Nest ds2 d;
                                                     0# -> d
                                                   }
                                                   }
                                                   })))
                                        (Cat
                                           line
                                           (Cat
                                              ($fIsStringDoc_$cfromString (unpackCString# " in "#))
                                              ($fIsStringDoc_$cfromString
                                                 (!!!
                                                    ($dIP6
                                                     `cast` <Co:4> :: CallStack
                                                                      ~R# (?callStack::CallStack))
                                                    binds
                                                    r1)))))))
                         })))
          }

$fPrintClosurekTYPErBaseHeapRootm
  = \ @k @r @t @m $dPrintClosure34 $dMonadHeapPrint1 ->
      C:PrintClosure
        ($cp1PrintClosure5 $dPrintClosure34 $dMonadHeapPrint1)
        ($cpClosImpl10 $dPrintClosure34 $dMonadHeapPrint1)

$cpClosImpl11
  = \ @k
      @k1
      @b
      @m
      @r
      @f
      $dMonadHeapPrint1
      $dPrintClosure34
      $dPrintClosure35 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec hge0 ->
        letrec {
          isList
            = \ @a hge ->
                case hge of { HeapGraphEntry ds1 ds2 ds3 ds4 ->
                join {
                  $j
                    = (>>=
                         $dMonad1
                         (case isCons ds2 of {
                            Nothing -> return $dMonad1 Nothing;
                            Just a1 -> return $dMonad1 (Just a1)
                          })
                         (\ v ->
                            case v of {
                              Nothing -> return $dMonad1 Nothing;
                              Just y ->
                                case y of { (h, t) ->
                                >>=
                                  $dMonad1
                                  (case t of {
                                     Nothing -> return $dMonad1 Nothing;
                                     Just a1 -> return $dMonad1 (Just a1)
                                   })
                                  (\ v1 ->
                                     case v1 of {
                                       Nothing -> return $dMonad1 Nothing;
                                       Just y1 ->
                                         >>=
                                           $dMonad1
                                           (lookupHeapUnbound $dMonadHeapPrint1 y1)
                                           (\ v2 ->
                                              case v2 of {
                                                Nothing -> return $dMonad1 Nothing;
                                                Just y2 ->
                                                  fmap
                                                    $dFunctor
                                                    (\ ds7 ->
                                                       case ds7 of {
                                                         Nothing -> Nothing;
                                                         Just a1 -> Just (: h a1)
                                                       })
                                                    ((isList y2)
                                                     `cast` <Co:5> :: MaybeT
                                                                        m [Maybe HeapGraphIndex]
                                                                      ~R# m (Maybe
                                                                               [Maybe
                                                                                  HeapGraphIndex]))
                                              })
                                     })
                                }
                            }))
                      `cast` <Co:6> :: m (Maybe [Maybe HeapGraphIndex])
                                       ~R# MaybeT m [Maybe HeapGraphIndex] } in
                case ds2 of {
                  __DEFAULT -> jump $j;
                  ConstrClosure ds ds7 ds8 ds9 ds10 ds11 ->
                    case eqString ds11 (unpackCString# "[]"#) of {
                      False -> jump $j;
                      True ->
                        case ds8 of {
                          [] ->
                            case ds7 of {
                              [] ->
                                (return $dMonad1 (Just []))
                                `cast` <Co:6> :: m (Maybe [Maybe HeapGraphIndex])
                                                 ~R# MaybeT m [Maybe HeapGraphIndex];
                              : ipv ipv1 -> jump $j
                            };
                          : ipv ipv1 -> jump $j
                        }
                    }
                }
                }; } in
        >>=
          $dMonad1
          (let { $dMonad2 = $fMonadMaybeT $dMonad1 } in
           >>=
             $dMonad1
             ((isList hge0)
              `cast` <Co:5> :: MaybeT m [Maybe HeapGraphIndex]
                               ~R# m (Maybe [Maybe HeapGraphIndex]))
             (\ v ->
                case v of {
                  Nothing -> return $dMonad1 Nothing;
                  Just y ->
                    case y of wild1 {
                      [] -> return $dMonad1 Nothing;
                      : ds1 ds2 ->
                        (mapM
                           $fTraversable[]
                           $dMonad2
                           (let { g = lookupHeapUnbound $dMonadHeapPrint1 } in
                            (\ eta ->
                               >>=
                                 $dMonad1
                                 (>>=
                                    $dMonad1
                                    (case eta of {
                                       Nothing -> return $dMonad1 Nothing;
                                       Just a -> return $dMonad1 (Just a)
                                     })
                                    (\ v1 ->
                                       case v1 of {
                                         Nothing -> return $dMonad1 Nothing;
                                         Just y1 -> g y1
                                       }))
                                 (\ v1 ->
                                    case v1 of {
                                      Nothing -> return $dMonad1 Nothing;
                                      Just y1 ->
                                        case isChar
                                               (case y1 of { HeapGraphEntry ds4 ds5 ds3 ds6 ->
                                                ds5
                                                })
                                        of {
                                          Nothing -> return $dMonad1 Nothing;
                                          Just a -> return $dMonad1 (Just a)
                                        }
                                    }))
                            `cast` <Co:8> :: (Maybe HeapGraphIndex -> m (Maybe Char))
                                             ~R# (Maybe HeapGraphIndex -> MaybeT m Char))
                           wild1)
                        `cast` <Co:3> :: MaybeT m String ~R# m (Maybe String)
                    }
                }))
          (\ ds ->
             case ds of {
               Nothing ->
                 >>=
                   $dMonad1
                   ((isList hge0)
                    `cast` <Co:5> :: MaybeT m [Maybe HeapGraphIndex]
                                     ~R# m (Maybe [Maybe HeapGraphIndex]))
                   (\ ds1 ->
                      case ds1 of {
                        Nothing ->
                          >>=
                            $dMonad1
                            (getHeapContent $dMonadHeapPrint1)
                            (\ _ -> pClos1 $dIP4 $dPrintClosure35 prec hge0);
                        Just l ->
                          fmap
                            $dFunctor
                            list
                            (traverse
                               $fTraversable[]
                               $dApplicative1
                               (let { a = I# 0# } in
                                \ x ->
                                  pClosImpl
                                    $dPrintClosure34
                                    $dIP4
                                    (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                    a
                                    x)
                               l)
                      });
               Just s ->
                 pure
                   $dApplicative1
                   ($fIsStringDoc_$cfromString
                      (: $fShow(,)13 (showLitString s (: $fShow(,)13 []))))
             })

$fPrintClosurekTYPErPrettyListLiteralsHeapGraphEntrym
  = \ @k
      @k1
      @b
      @m
      @r
      @f
      $dMonadHeapPrint1
      $dPrintClosure34
      $dPrintClosure35 ->
      C:PrintClosure
        ($p1Monad ($p1MonadHeapPrint $dMonadHeapPrint1))
        ($cpClosImpl11 $dMonadHeapPrint1 $dPrintClosure34 $dPrintClosure35)

$trModule1 = "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#

$trModule2 = TrNameS $trModule1

$trModule3 = "HeapUtils"#

$trModule4 = TrNameS $trModule3

$trModule = Module $trModule2 $trModule4

$krep = "\"printLocal\""#

$krep1 = KindRepTypeLitS TypeLitSymbol $krep

$krep2 = "\"printBase\""#

$krep3 = KindRepTypeLitS TypeLitSymbol $krep2

$krep4 = KindRepTyConApp $tcInt []

$krep5 = KindRepTyConApp $tcConstraint []

$krep6 = KindRepTyConApp $tcAttr []

$krep7 = KindRepTyConApp $tcChar []

$krep8 = : $krep6 []

$krep9 = KindRepTyConApp $tcDoc $krep8

$krep10 = : $krep6 []

$krep11 = KindRepTyConApp $tcIntMap $krep10

$krep12 = : $krep7 []

$krep13 = KindRepTyConApp $tc[] $krep12

$krep14 = : $krep13 []

$krep15 = KindRepTyConApp $tcIntMap $krep14

$krep16 = KindRepFun krep$*Arr* $krep5

$krep17 = KindRepFun krep$* $krep16

$krep18 = KindRepFun krep$*Arr* krep$*Arr*

$krep19 = KindRepFun krep$* $krep18

$krep20 = KindRepVar 4#

$krep21 = KindRepVar 2#

$krep22 = KindRepVar 1#

$krep23 = KindRepFun $krep22 $krep17

$krep24 = KindRepFun $krep22 krep$*

$krep25 = KindRepVar 0#

$krep26 = KindRepFun $krep25 $krep23

$krep27 = KindRepFun $krep25 $krep24

$krep28 = KindRepFun $krep25 krep$*

$krep29 = : $krep25 []

$krep30 = KindRepTyConApp $tcHeapGraph $krep29

$krep31 = : $krep15 []

$krep32 = : $krep30 $krep31

$krep33 = KindRepTyConApp $tc(,) $krep32

$krep34 = : $krep25 []

$krep35 = KindRepTyConApp $tcHeapGraphEntry $krep34

$krep36 = KindRepVar 5#

$krep37 = KindRepApp $krep36 $krep9

$krep38 = KindRepFun $krep20 $krep37

$krep39 = KindRepFun $krep4 $krep38

$krep40 = : $krep36 []

$krep41 = KindRepTyConApp $tcApplicative $krep40

$krep42 = KindRepVar 1#

$krep43 = KindRepApp $krep42 $krep15

$krep44 = KindRepApp $krep42 $krep30

$krep45 = : $krep21 []

$krep46 = : $krep42 $krep45

$krep47 = : $krep33 $krep46

$krep48 = KindRepTyConApp $tcReaderT $krep47

$krep49 = : $krep42 []

$krep50 = KindRepTyConApp $tcMonad $krep49

$krep51 = KindRepVar 0#

$krep52 = KindRepApp $krep51 $krep11

$krep53 = : $krep22 []

$krep54 = : $krep51 $krep53

$krep55 = : $krep11 $krep54

$krep56 = KindRepTyConApp $tcReaderT $krep55

$krep57 = : $krep51 []

$krep58 = KindRepTyConApp $tcMonad $krep57

$krep59 = KindRepVar 3#

$krep60 = : $krep59 []

$krep61 = : $krep22 $krep60

$krep62 = KindRepTyConApp $tcProxy# $krep61

$krep63 = : $krep62 []

$krep64 = : $krep1 $krep63

$krep65 = KindRepTyConApp $tcIP $krep64

$krep66 = KindRepFun $krep65 $krep39

$krep67 = KindRepVar 2#

$krep68 = : $krep67 []

$krep69 = : $krep25 $krep68

$krep70 = KindRepTyConApp $tcProxy# $krep69

$krep71 = : $krep70 []

$krep72 = : $krep3 $krep71

$krep73 = KindRepTyConApp $tcIP $krep72

$krep74 = KindRepFun $krep73 $krep66

$tcNamedThunks1 = "NamedThunks"#

$tcNamedThunks2 = TrNameS $tcNamedThunks1

$tcNamedThunks
  = TyCon
      16940524130248433816##64
      10703467182719248520##64
      $trModule
      $tcNamedThunks2
      1#
      $krep28

$tcPrettyListLiterals1 = "PrettyListLiterals"#

$tcPrettyListLiterals2 = TrNameS $tcPrettyListLiterals1

$tcPrettyListLiterals
  = TyCon
      1475729845294341320##64
      5940317455928483254##64
      $trModule
      $tcPrettyListLiterals2
      1#
      $krep28

$tcPrettyText1 = "PrettyText"#

$tcPrettyText2 = TrNameS $tcPrettyText1

$tcPrettyText
  = TyCon
      13983549703678983486##64
      10705492752301131532##64
      $trModule
      $tcPrettyText2
      1#
      $krep28

$tcElide1 = "Elide"#

$tcElide2 = TrNameS $tcElide1

$tcElide
  = TyCon
      15258727981397965161##64
      5046812752541504967##64
      $trModule
      $tcElide2
      2#
      $krep27

$tcPrintClosure1 = "PrintClosure"#

$tcPrintClosure2 = TrNameS $tcPrintClosure1

$tcPrintClosure
  = TyCon
      10715870330730227162##64
      2891202511837432102##64
      $trModule
      $tcPrintClosure2
      2#
      $krep26

$krep75 = : $krep36 []

$krep76 = : $krep20 $krep75

$krep77 = : $krep59 $krep76

$krep78 = : $krep67 $krep77

$krep79 = : $krep22 $krep78

$krep80 = : $krep25 $krep79

$krep81 = KindRepTyConApp $tcPrintClosure $krep80

$krep82 = KindRepFun $krep74 $krep81

$krep83 = KindRepFun $krep41 $krep82

$tc'C:PrintClosure1 = "'C:PrintClosure"#

$tc'C:PrintClosure2 = TrNameS $tc'C:PrintClosure1

$tc'C:PrintClosure
  = TyCon
      12792363699917352936##64
      17330472865061592089##64
      $trModule
      $tc'C:PrintClosure2
      6#
      $krep83

$tcHeapRoot1 = "HeapRoot"#

$tcHeapRoot2 = TrNameS $tcHeapRoot1

$tcHeapRoot
  = TyCon
      16320787393839418248##64
      12231918735598989381##64
      $trModule
      $tcHeapRoot2
      0#
      krep$*

$krep84 = KindRepTyConApp $tcHeapRoot []

$krep85 = KindRepFun $krep4 $krep84

$tc'HeapRoot1 = "'HeapRoot"#

$tc'HeapRoot2 = TrNameS $tc'HeapRoot1

$tc'HeapRoot
  = TyCon
      15116345743578642687##64
      4088251164208122752##64
      $trModule
      $tc'HeapRoot2
      0#
      $krep85

$tcHeapKV1 = "HeapKV"#

$tcHeapKV2 = TrNameS $tcHeapKV1

$tcHeapKV
  = TyCon
      15442278164442099450##64
      9590314007206807240##64
      $trModule
      $tcHeapKV2
      0#
      krep$*Arr*

$krep86 = : $krep25 []

$krep87 = KindRepTyConApp $tcHeapKV $krep86

$krep88 = KindRepFun $krep35 $krep87

$krep89 = KindRepFun $krep13 $krep88

$krep90 = KindRepFun $krep4 $krep89

$tc'HeapKV1 = "'HeapKV"#

$tc'HeapKV2 = TrNameS $tc'HeapKV1

$tc'HeapKV
  = TyCon
      13472336734162458493##64
      17632476175039328017##64
      $trModule
      $tc'HeapKV2
      1#
      $krep90

$tcMonadDecorate1 = "MonadDecorate"#

$tcMonadDecorate2 = TrNameS $tcMonadDecorate1

$tcMonadDecorate
  = TyCon
      5858529179829584112##64
      10179153855110236700##64
      $trModule
      $tcMonadDecorate2
      0#
      $krep16

$krep91 = : $krep51 []

$krep92 = KindRepTyConApp $tcMonadDecorate $krep91

$krep93 = KindRepFun $krep52 $krep92

$krep94 = KindRepFun $krep58 $krep93

$tc'C:MonadDecorate1 = "'C:MonadDecorate"#

$tc'C:MonadDecorate2 = TrNameS $tc'C:MonadDecorate1

$tc'C:MonadDecorate
  = TyCon
      2472037496869253838##64
      2509609770210679684##64
      $trModule
      $tc'C:MonadDecorate2
      1#
      $krep94

$tcDecorateElems1 = "DecorateElems"#

$tcDecorateElems2 = TrNameS $tcDecorateElems1

$tcDecorateElems
  = TyCon
      9865056640784120570##64
      10186460409221579448##64
      $trModule
      $tcDecorateElems2
      1#
      $krep28

$tcMonadHeapPrint1 = "MonadHeapPrint"#

$tcMonadHeapPrint2 = TrNameS $tcMonadHeapPrint1

$tcMonadHeapPrint
  = TyCon
      14334595219621928100##64
      1763771378747849501##64
      $trModule
      $tcMonadHeapPrint2
      0#
      $krep17

$krep95 = : $krep42 []

$krep96 = : $krep25 $krep95

$krep97 = KindRepTyConApp $tcMonadHeapPrint $krep96

$krep98 = KindRepFun $krep44 $krep97

$krep99 = KindRepFun $krep43 $krep98

$krep100 = KindRepFun $krep50 $krep99

$tc'C:MonadHeapPrint1 = "'C:MonadHeapPrint"#

$tc'C:MonadHeapPrint2 = TrNameS $tc'C:MonadHeapPrint1

$tc'C:MonadHeapPrint
  = TyCon
      15231624055606598072##64
      17610450527297938827##64
      $trModule
      $tc'C:MonadHeapPrint2
      2#
      $krep100

$tcDecorateT1 = "DecorateT"#

$tcDecorateT2 = TrNameS $tcDecorateT1

$tcDecorateT
  = TyCon
      17511994562757618798##64
      9250041382521115799##64
      $trModule
      $tcDecorateT2
      0#
      $krep18

$krep101 = : $krep22 []

$krep102 = : $krep51 $krep101

$krep103 = KindRepTyConApp $tcDecorateT $krep102

$krep104 = KindRepFun $krep56 $krep103

$tc'DecorateT1 = "'DecorateT"#

$tc'DecorateT2 = TrNameS $tc'DecorateT1

$tc'DecorateT
  = TyCon
      5288258427052301176##64
      7571200242534887037##64
      $trModule
      $tc'DecorateT2
      2#
      $krep104

$tcHeapPrintT1 = "HeapPrintT"#

$tcHeapPrintT2 = TrNameS $tcHeapPrintT1

$tcHeapPrintT
  = TyCon
      7524692127510196217##64
      15532567376436988153##64
      $trModule
      $tcHeapPrintT2
      0#
      $krep19

$krep105 = : $krep21 []

$krep106 = : $krep42 $krep105

$krep107 = : $krep25 $krep106

$krep108 = KindRepTyConApp $tcHeapPrintT $krep107

$krep109 = KindRepFun $krep48 $krep108

$tc'HeapPrintT1 = "'HeapPrintT"#

$tc'HeapPrintT2 = TrNameS $tc'HeapPrintT1

$tc'HeapPrintT
  = TyCon
      14711388777412766433##64
      15097871142319285211##64
      $trModule
      $tc'HeapPrintT2
      3#
      $krep109

$dApplicative = $fApplicativeDecorateT $fApplicativeIdentity

$dPrintClosure = $fPrintClosurekTYPErElidetm $dApplicative

$dMonad = $fMonadDecorateT $fMonadIdentity

$dMonadHeapPrint = $fMonadHeapPrinttHeapPrintT $dMonad

$dMonadDecorate = $fMonadDecorateDecorateT $fMonadIdentity

$dPrintClosure1
  = $fPrintClosurekTYPErDecorateElemsbm
      $dPrintClosure $dMonadDecorate

$dPrintClosure2 = $fPrintClosurekTYPErPrettyTextbm $dPrintClosure1

ppClosureDoc
  = \ a b c ->
      runIdentity
        ((($cpClosImpl7
             $dPrintClosure2
             (proxy#
              `cast` <Co:6> :: Proxy# Printer ~R# (?printBase::Proxy# Printer))
             (proxy#
              `cast` <Co:6> :: Proxy# Base ~R# (?printLocal::Proxy# Base))
             b
             c)
          `cast` <Co:11> :: DecorateT Identity (Doc Attr)
                            ~R# (IntMap Attr -> Identity (Doc Attr)))
           a)

$dMonadDecorate1 = $fMonadDecorateHeapPrintT $dMonadDecorate

Rec {
$dPrintClosure3 = $fPrintClosurekTYPErElidesm $dPrintClosure26

$dPrintClosure4
  = $fPrintClosurekTYPErDecorateElemsbm
      $dPrintClosure3 $dMonadDecorate1

$dPrintClosure5
  = $fPrintClosurekTYPErPrettyTextHeapGraphEntrym
      $dMonadHeapPrint $dPrintClosure4

$dPrintClosure6
  = $fPrintClosurekTYPErBaseIntm $dMonadHeapPrint $dPrintClosure5

$dPrintClosure7 = $fPrintClosurekTYPErNamedThunksbm $dPrintClosure6

$dPrintClosure8
  = $fPrintClosurekTYPErPrettyListLiteralsbm $dPrintClosure7

$dPrintClosure9 = $fPrintClosurekTYPErElidesm $dPrintClosure8

$dPrintClosure10
  = $fPrintClosurekTYPErDecorateElemsIntm
      $dPrintClosure9 $dMonadDecorate1

$dPrintClosure11
  = $fPrintClosurekTYPErPrettyTextbm $dPrintClosure10

$dPrintClosure12 = $fPrintClosurekTYPErBaseMaybem $dPrintClosure11

$dPrintClosure13
  = $fPrintClosurekTYPErNamedThunksbm $dPrintClosure12

$dPrintClosure14
  = $fPrintClosurekTYPErPrettyListLiteralsbm $dPrintClosure13

$dPrintClosure15 = $fPrintClosurekTYPErElidesm $dPrintClosure14

$dPrintClosure16
  = $fPrintClosurekTYPErDecorateElemsbm
      $dPrintClosure15 $dMonadDecorate1

$dPrintClosure17
  = $fPrintClosurekTYPErPrettyTextbm $dPrintClosure16

$dPrintClosure18
  = $fPrintClosurekTYPErBaseGenClosurem $dPrintClosure17

$dPrintClosure19
  = $fPrintClosurekTYPErNamedThunksbm $dPrintClosure18

$dPrintClosure20
  = $fPrintClosurekTYPErPrettyListLiteralsbm $dPrintClosure19

$dPrintClosure21 = $fPrintClosurekTYPErElidesm $dPrintClosure20

$dPrintClosure22
  = $fPrintClosurekTYPErDecorateElemsbm
      $dPrintClosure21 $dMonadDecorate1

$dPrintClosure23
  = $fPrintClosurekTYPErPrettyTextbm $dPrintClosure22

$dPrintClosure24
  = $fPrintClosurekTYPErBaseHeapGraphEntrym $dPrintClosure23

$dPrintClosure25
  = $fPrintClosurekTYPErNamedThunksHeapGraphEntrym
      $dPrintClosure17 $dPrintClosure24

$dPrintClosure26
  = $fPrintClosurekTYPErPrettyListLiteralsHeapGraphEntrym
      $dMonadHeapPrint $dPrintClosure17 $dPrintClosure25
end Rec }

$dPrintClosure27
  = $fPrintClosurekTYPErPrettyTextHeapGraphEntrym
      $dMonadHeapPrint $dPrintClosure4

$dPrintClosure28
  = $fPrintClosurekTYPErBaseHeapKVm $dPrintClosure27 $dMonadHeapPrint

$dPrintClosure29
  = $fPrintClosurekTYPErNamedThunksbm $dPrintClosure28

$dPrintClosure30
  = $fPrintClosurekTYPErPrettyListLiteralsbm $dPrintClosure29

$dPrintClosure31 = $fPrintClosurekTYPErElidesm $dPrintClosure30

$dPrintClosure32
  = $fPrintClosurekTYPErDecorateElemsHeapKVm
      $dMonadDecorate1 $dPrintClosure31

$dPrintClosure33
  = $fPrintClosurekTYPErPrettyTextbm $dPrintClosure32

ppHeapGraph'
  = \ attrs hg ->
      runIdentity
        ((((($cpClosImpl10
               $dPrintClosure33
               $dMonadHeapPrint
               (proxy#
                `cast` <Co:6> :: Proxy# Printer ~R# (?printBase::Proxy# Printer))
               (proxy#
                `cast` <Co:6> :: Proxy# Base ~R# (?printLocal::Proxy# Base))
               (I# 0#)
               (HeapRoot (I# 0#)))
            `cast` <Co:17> :: HeapPrintT
                                HeapData (DecorateT Identity) (Doc Attr)
                              ~R# ((HeapGraph HeapData, IntMap String)
                                   -> DecorateT Identity (Doc Attr)))
             (hg, mkBindingMap hg))
          `cast` <Co:11> :: DecorateT Identity (Doc Attr)
                            ~R# (IntMap Attr -> Identity (Doc Attr)))
           attrs)



[9 of 9] Compiling Lib

/home/lana/Projects/HaskellDebug/src/Lib.hs:13:1: warning: [-Wunused-imports]
    The import of ‘Data.Text.Prettyprint.Doc’ is redundant
      except perhaps to import instances from ‘Data.Text.Prettyprint.Doc’
    To import instances alone, use: import Data.Text.Prettyprint.Doc()
   |
13 | import Data.Text.Prettyprint.Doc (pretty)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/lana/Projects/HaskellDebug/src/Lib.hs:13:1: warning: [-Wdeprecations]
    Module ‘Data.Text.Prettyprint.Doc’ is deprecated:
      "Use \"Prettyprinter\" instead."
   |
13 | import Data.Text.Prettyprint.Doc (pretty)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/lana/Projects/HaskellDebug/src/Lib.hs:28:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘foo’
   |
28 | foo ls =  scanl (+) 0 (map (*2) ls)
   | ^^^

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 63, types: 75, coercions: 5, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Lib.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 120 0}]
Lib.$trModule4 = "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Lib.$trModule3 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Lib.$trModule3 = GHC.Types.TrNameS Lib.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Lib.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Lib.$trModule2 = "Lib"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Lib.$trModule1 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Lib.$trModule1 = GHC.Types.TrNameS Lib.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Lib.$trModule :: GHC.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Lib.$trModule = GHC.Types.Module Lib.$trModule3 Lib.$trModule1

-- RHS size: {terms: 24, types: 29, coercions: 0, joins: 0/0}
Lib.someFunc4 :: Data.Text.Internal.Text
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 52 0}]
Lib.someFunc4
  = GHC.Magic.runRW#
      @GHC.Types.LiftedRep
      @Data.Text.Internal.Text
      (\ (s [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
         case GHC.Prim.newByteArray# @GHC.Prim.RealWorld 3# s of
         { (# ipv, ipv1 #) ->
         case GHC.Prim.copyAddrToByteArray#
                @GHC.Prim.RealWorld Lib.$trModule2 ipv1 0# 3# ipv
         of s2#
         { __DEFAULT ->
         case GHC.Prim.unsafeFreezeByteArray# @GHC.Prim.RealWorld ipv1 s2#
         of
         { (# ipv2, ipv3 #) ->
         Data.Text.Internal.Text ipv3 0# 3#
         }
         }
         })

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Lib.someFunc3 :: Int
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Lib.someFunc3 = GHC.Types.I# 25#

-- RHS size: {terms: 3, types: 2, coercions: 2, joins: 0/0}
Lib.someFunc2 :: Requests (Maybe GhcDump.Ast.Module)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Lib.someFunc2
  = State.LoadGhcDump
      @(Maybe GhcDump.Ast.Module)
      @~(<Maybe GhcDump.Ast.Module>_N
         :: Maybe GhcDump.Ast.Module GHC.Prim.~# Maybe GhcDump.Ast.Module)
      (src<src/Lib.hs:17:33-37> Lib.someFunc4)
      (src<src/Lib.hs:17:39-40> Lib.someFunc3)

-- RHS size: {terms: 14, types: 24, coercions: 0, joins: 0/0}
Lib.someFunc1 [InlPrag=[2]]
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=1,
 Str=<L>,
 Cpr=1(, 1),
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (s [Occ=Once1] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 src<src/Lib.hs:(16,1)-(18,15)>
                 case State.runRequest1 @(Maybe GhcDump.Ast.Module) Lib.someFunc2 s
                 of
                 { (# ipv [Occ=Once1], ipv1 [Occ=Once1] #) ->
                 src<src/Lib.hs:18:4-15>
                 case UI.$wprintValue @(Maybe GhcDump.Ast.Module) ipv1 ipv
                 of ww [Occ=Once1]
                 { __DEFAULT ->
                 (# ww, GHC.Tuple.() #)
                 }
                 }}]
Lib.someFunc1
  = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      src<src/Lib.hs:(16,1)-(18,15)>
      case State.runRequest1 @(Maybe GhcDump.Ast.Module) Lib.someFunc2 s
      of
      { (# ipv, ipv1 #) ->
      src<src/Lib.hs:18:4-15>
      case UI.$wprintValue @(Maybe GhcDump.Ast.Module) ipv1 ipv of ww
      { __DEFAULT ->
      (# ww, GHC.Tuple.() #)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
someFunc :: IO ()
[GblId,
 Arity=1,
 Str=<L>,
 Cpr=1(, 1),
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
someFunc
  = Lib.someFunc1
    `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
            :: (GHC.Prim.State# GHC.Prim.RealWorld
                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
               ~R# IO ())



[7 of 9] Compiling HeapUtils [Source file changed]

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:1:1: warning: [-Wmissing-export-lists]
    The export item ‘module HeapUtils’ is missing an export list
  |
1 | {-# LANGUAGE RecordWildCards #-}
  | ^

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:23:41: warning: [-Wunused-imports]
    The import of ‘isJust’ from module ‘Data.Maybe’ is redundant
   |
23 | import Data.Maybe (catMaybes, fromJust, isJust)
   |                                         ^^^^^^

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:37:1: warning: [-Wunused-imports]
    The qualified import of ‘Data.IntSet’ is redundant
      except perhaps to import instances from ‘Data.IntSet’
    To import instances alone, use: import Data.IntSet()
   |
37 | import qualified Data.IntSet as IS
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:39:1: warning: [-Wunused-imports]
    The import of ‘Debug.Trace’ is redundant
      except perhaps to import instances from ‘Debug.Trace’
    To import instances alone, use: import Debug.Trace()
   |
39 | import Debug.Trace
   | ^^^^^^^^^^^^^^^^^^

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:44:1: warning: [-Wunused-imports]
    The qualified import of ‘Data.Text.Array’ is redundant
      except perhaps to import instances from ‘Data.Text.Array’
    To import instances alone, use: import Data.Text.Array()
   |
44 | import qualified Data.Text.Array as A
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/lana/Projects/HaskellDebug/src/HeapUtils.hs:353:52: warning: [-Wtype-defaults]
    • Defaulting the type variable ‘a0’ to type ‘Integer’ in the following constraints
        (Ord a0) arising from a use of ‘>’ at src/HeapUtils.hs:353:52
        (Num a0) arising from the literal ‘1’ at src/HeapUtils.hs:353:54
    • In the expression: (>)
      In the first argument of ‘filter’, namely ‘(> 1)’
      In the first argument of ‘($)’, namely ‘filter (> 1)’
    |
353 |     bindings = nubOrd $ (0:) $ M.keys $  M.filter (> 1) $ M.fromListWith (+) $ map (,1) $ concatMap (catMaybes . allClosures . hgeClosure) (IM.elems m)
    |                                                    ^

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 4,226, types: 9,863, coercions: 3,037, joins: 2/115}

$p1MonadHeapPrint
  = \ @k[sk:1] @m[sk:1] v ->
      case v of v { C:MonadHeapPrint v v v -> v }

getHeapBindings
  = \ @k[sk:1] @m[sk:1] v ->
      case v of v { C:MonadHeapPrint v v v -> v }

getHeapContent
  = \ @k[sk:1] @m[sk:1] v ->
      case v of v { C:MonadHeapPrint v v v -> v }

$p1MonadDecorate
  = \ @m[sk:1] v -> case v of v { C:MonadDecorate v v -> v }

decorateMap
  = \ @m[sk:1] v -> case v of v { C:MonadDecorate v v -> v }

$p1PrintClosure
  = \ @k[sk:1] @k[sk:1] @r[sk:1] @t[sk:1] @f[sk:1] @m[sk:1] v ->
      case v of v { C:PrintClosure v v -> v }

pClosImpl
  = \ @k[sk:1] @k[sk:1] @r[sk:1] @t[sk:1] @f[sk:1] @m[sk:1] v ->
      case v of v { C:PrintClosure v v -> v }

$cpClosImpl
  = \ @k @k1 @m @r @t @f $dApplicative1 _ _ _ _ ->
      pure $dApplicative1 (list_$cfromString (unpackCString# "..."#))

$fPrintClosurekTYPErElidetm
  = \ @k @k1 @m @r @t @f $dApplicative1 ->
      C:PrintClosure $dApplicative1 ($cpClosImpl $dApplicative1)

$cp1PrintClosure
  = \ @k @k1 @m @r @f @t $dMonadDecorate2 _ ->
      $p1Monad ($p1MonadDecorate $dMonadDecorate2)

$cp1PrintClosure1
  = \ @k @k1 @r @x @m _ $dMonadDecorate2 ->
      $p1Monad ($p1MonadDecorate $dMonadDecorate2)

$cp1PrintClosure2
  = \ @k @k1 @r @x @b @m _ $dMonadDecorate2 ->
      $p1Monad ($p1MonadDecorate $dMonadDecorate2)

$cp1PrintClosure3
  = \ @k @b @m @r $dMonadHeapPrint1 _ ->
      $p1Monad ($p1MonadHeapPrint $dMonadHeapPrint1)

$cp1PrintClosure4
  = \ @k @k1 @b @m @r @f $dMonadHeapPrint1 _ ->
      $p1Monad ($p1MonadHeapPrint $dMonadHeapPrint1)

$cp1PrintClosure5
  = \ @k @r @t @m _ $dMonadHeapPrint1 ->
      $p1Monad ($p1MonadHeapPrint $dMonadHeapPrint1)

$cp1PrintClosure6
  = \ @k @r @t @m _ $dMonadHeapPrint1 ->
      $p1Monad ($p1MonadHeapPrint $dMonadHeapPrint1)

$cgetHeapContent
  = \ @m @t $dMonad1 -> \ eta -> return $dMonad1 (fst eta)

$cgetHeapBindings
  = \ @m @t $dMonad1 -> \ eta -> return $dMonad1 (snd eta)

$clift = \ @m @a _ -> \ eta _ -> eta

$fMonadTransDecorateT
  = $clift
    `cast` <Co:28> :: (forall {m :: * -> *} {a}.
                       Monad m =>
                       m a -> IntMap Attr -> m a)
                      ~R# MonadTrans DecorateT

$fFunctorDecorateT
  = \ @m $dFunctor ->
      C:Functor
        ((\ @a @b -> ($fFunctorReaderT_$cfmap $dFunctor))
         `cast` <Co:18> :: (forall {a} {b}.
                            (a -> b) -> ReaderT (IntMap Attr) m a -> ReaderT (IntMap Attr) m b)
                           ~R# (forall {a} {b}. (a -> b) -> DecorateT m a -> DecorateT m b))
        ((\ @a @b -> ($fFunctorReaderT_$c<$ $dFunctor))
         `cast` <Co:17> :: (forall {a} {b}.
                            a -> ReaderT (IntMap Attr) m b -> ReaderT (IntMap Attr) m a)
                           ~R# (forall {a} {b}. a -> DecorateT m b -> DecorateT m a))

$cp1Applicative
  = \ @m $dApplicative1 ->
      $fFunctorDecorateT ($p1Applicative $dApplicative1)

$fApplicativeDecorateT
  = \ @m $dApplicative1 ->
      C:Applicative
        ($cp1Applicative $dApplicative1)
        ((\ @a -> ($fApplicativeReaderT_$cpure $dApplicative1))
         `cast` <Co:9> :: (forall {a}. a -> ReaderT (IntMap Attr) m a)
                          ~R# (forall {a}. a -> DecorateT m a))
        ((\ @a @b -> ($fApplicativeReaderT_$c<*> $dApplicative1))
         `cast` <Co:21> :: (forall {a} {b}.
                            ReaderT (IntMap Attr) m (a -> b)
                            -> ReaderT (IntMap Attr) m a -> ReaderT (IntMap Attr) m b)
                           ~R# (forall {a} {b}.
                                DecorateT m (a -> b) -> DecorateT m a -> DecorateT m b))
        ((\ @a @b @c -> ($fApplicativeReaderT_$cliftA2 $dApplicative1))
         `cast` <Co:27> :: (forall {a} {b} {c}.
                            (a -> b -> c)
                            -> ReaderT (IntMap Attr) m a
                            -> ReaderT (IntMap Attr) m b
                            -> ReaderT (IntMap Attr) m c)
                           ~R# (forall {a} {b} {c}.
                                (a -> b -> c) -> DecorateT m a -> DecorateT m b -> DecorateT m c))
        ((\ @a @b -> ($fApplicativeReaderT_$c*> $dApplicative1))
         `cast` <Co:20> :: (forall {a} {b}.
                            ReaderT (IntMap Attr) m a
                            -> ReaderT (IntMap Attr) m b -> ReaderT (IntMap Attr) m b)
                           ~R# (forall {a} {b}.
                                DecorateT m a -> DecorateT m b -> DecorateT m b))
        ((\ @a @b -> ($fApplicativeReaderT_$c<* $dApplicative1))
         `cast` <Co:20> :: (forall {a} {b}.
                            ReaderT (IntMap Attr) m a
                            -> ReaderT (IntMap Attr) m b -> ReaderT (IntMap Attr) m a)
                           ~R# (forall {a} {b}.
                                DecorateT m a -> DecorateT m b -> DecorateT m a))

$cp1Monad
  = \ @m $dMonad1 -> $fApplicativeDecorateT ($p1Monad $dMonad1)

$fMonadDecorateT
  = \ @m $dMonad1 ->
      C:Monad
        ($cp1Monad $dMonad1)
        ((\ @a @b -> ($fMonadReaderT_$c>>= $dMonad1))
         `cast` <Co:23> :: (forall {a} {b}.
                            ReaderT (IntMap Attr) m a
                            -> (a -> ReaderT (IntMap Attr) m b) -> ReaderT (IntMap Attr) m b)
                           ~R# (forall {a} {b}.
                                DecorateT m a -> (a -> DecorateT m b) -> DecorateT m b))
        ((\ @a @b -> ($fMonadReaderT_$c>> $dMonad1))
         `cast` <Co:20> :: (forall {a} {b}.
                            ReaderT (IntMap Attr) m a
                            -> ReaderT (IntMap Attr) m b -> ReaderT (IntMap Attr) m b)
                           ~R# (forall {a} {b}.
                                DecorateT m a -> DecorateT m b -> DecorateT m b))
        ((\ @a -> ($fMonadReaderT_$creturn $dMonad1))
         `cast` <Co:9> :: (forall {a}. a -> ReaderT (IntMap Attr) m a)
                          ~R# (forall {a}. a -> DecorateT m a))

$cp1MonadHeapPrint
  = \ @t @m $dMonadHeapPrint1 ->
      $fMonadDecorateT ($p1MonadHeapPrint $dMonadHeapPrint1)

$fMonadDecorateDecorateT
  = \ @m $dMonad1 ->
      C:MonadDecorate
        ($fMonadDecorateT $dMonad1)
        ((return $dMonad1)
         `cast` <Co:13> :: (IntMap Attr -> m (IntMap Attr))
                           ~R# DecorateT m (IntMap Attr))

$cstate
  = \ @s @t @m $dMonadState @a ->
      let { $dMonadState1 = $fMonadStatesReaderT $dMonadState } in
      (state $dMonadState1)
      `cast` <Co:11> :: ((s -> (a, s))
                         -> ReaderT (HeapGraph t, IntMap String) m a)
                        ~R# ((s -> (a, s)) -> HeapPrintT t m a)

$cput
  = \ @s @t @m $dMonadState ->
      let { $dMonadState1 = $fMonadStatesReaderT $dMonadState } in
      (put $dMonadState1)
      `cast` <Co:8> :: (s -> ReaderT (HeapGraph t, IntMap String) m ())
                       ~R# (s -> HeapPrintT t m ())

$cget
  = \ @s @t @m $dMonadState ->
      let { $dMonadState1 = $fMonadStatesReaderT $dMonadState } in
      (get $dMonadState1)
      `cast` <Co:5> :: ReaderT (HeapGraph t, IntMap String) m s
                       ~R# HeapPrintT t m s

$clift1 = \ @t @m @a _ -> \ eta _ -> eta

$fMonadTransHeapPrintT
  = $clift1
    `cast` <Co:35> :: (forall {t} {m :: * -> *} {a}.
                       Monad m =>
                       m a -> (HeapGraph t, IntMap String) -> m a)
                      ~R# (forall {t}. MonadTrans (HeapPrintT t))

$fFunctorHeapPrintT
  = \ @t @m $dFunctor ->
      C:Functor
        ((\ @a @b -> ($fFunctorReaderT_$cfmap $dFunctor))
         `cast` <Co:20> :: (forall {a} {b}.
                            (a -> b)
                            -> ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b)
                           ~R# (forall {a} {b}.
                                (a -> b) -> HeapPrintT t m a -> HeapPrintT t m b))
        ((\ @a @b -> ($fFunctorReaderT_$c<$ $dFunctor))
         `cast` <Co:19> :: (forall {a} {b}.
                            a
                            -> ReaderT (HeapGraph t, IntMap String) m b
                            -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a} {b}. a -> HeapPrintT t m b -> HeapPrintT t m a))

$cp1Applicative1
  = \ @t @m $dApplicative1 ->
      $fFunctorHeapPrintT ($p1Applicative $dApplicative1)

$fApplicativeHeapPrintT
  = \ @t @m $dApplicative1 ->
      C:Applicative
        ($cp1Applicative1 $dApplicative1)
        ((\ @a -> ($fApplicativeReaderT_$cpure $dApplicative1))
         `cast` <Co:10> :: (forall {a}.
                            a -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a}. a -> HeapPrintT t m a))
        ((\ @a @b -> ($fApplicativeReaderT_$c<*> $dApplicative1))
         `cast` <Co:24> :: (forall {a} {b}.
                            ReaderT (HeapGraph t, IntMap String) m (a -> b)
                            -> ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b)
                           ~R# (forall {a} {b}.
                                HeapPrintT t m (a -> b) -> HeapPrintT t m a -> HeapPrintT t m b))
        ((\ @a @b @c -> ($fApplicativeReaderT_$cliftA2 $dApplicative1))
         `cast` <Co:30> :: (forall {a} {b} {c}.
                            (a -> b -> c)
                            -> ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b
                            -> ReaderT (HeapGraph t, IntMap String) m c)
                           ~R# (forall {a} {b} {c}.
                                (a -> b -> c)
                                -> HeapPrintT t m a -> HeapPrintT t m b -> HeapPrintT t m c))
        ((\ @a @b -> ($fApplicativeReaderT_$c*> $dApplicative1))
         `cast` <Co:23> :: (forall {a} {b}.
                            ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b
                            -> ReaderT (HeapGraph t, IntMap String) m b)
                           ~R# (forall {a} {b}.
                                HeapPrintT t m a -> HeapPrintT t m b -> HeapPrintT t m b))
        ((\ @a @b -> ($fApplicativeReaderT_$c<* $dApplicative1))
         `cast` <Co:23> :: (forall {a} {b}.
                            ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b
                            -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a} {b}.
                                HeapPrintT t m a -> HeapPrintT t m b -> HeapPrintT t m a))

$cp1Monad1
  = \ @t @m $dMonad1 -> $fApplicativeHeapPrintT ($p1Monad $dMonad1)

$fMonadHeapPrintT
  = \ @t @m $dMonad1 ->
      C:Monad
        ($cp1Monad1 $dMonad1)
        ((\ @a @b -> ($fMonadReaderT_$c>>= $dMonad1))
         `cast` <Co:26> :: (forall {a} {b}.
                            ReaderT (HeapGraph t, IntMap String) m a
                            -> (a -> ReaderT (HeapGraph t, IntMap String) m b)
                            -> ReaderT (HeapGraph t, IntMap String) m b)
                           ~R# (forall {a} {b}.
                                HeapPrintT t m a -> (a -> HeapPrintT t m b) -> HeapPrintT t m b))
        ((\ @a @b -> ($fMonadReaderT_$c>> $dMonad1))
         `cast` <Co:23> :: (forall {a} {b}.
                            ReaderT (HeapGraph t, IntMap String) m a
                            -> ReaderT (HeapGraph t, IntMap String) m b
                            -> ReaderT (HeapGraph t, IntMap String) m b)
                           ~R# (forall {a} {b}.
                                HeapPrintT t m a -> HeapPrintT t m b -> HeapPrintT t m b))
        ((\ @a -> ($fMonadReaderT_$creturn $dMonad1))
         `cast` <Co:10> :: (forall {a}.
                            a -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a}. a -> HeapPrintT t m a))

$cp1MonadIO
  = \ @t @m $dMonadIO -> $fMonadHeapPrintT ($p1MonadIO $dMonadIO)

$fMonadIOHeapPrintT
  = \ @t @m $dMonadIO ->
      C:MonadIO
        ($cp1MonadIO $dMonadIO)
        ((\ @a -> ($fMonadIOReaderT_$cliftIO $dMonadIO))
         `cast` <Co:11> :: (forall {a}.
                            IO a -> ReaderT (HeapGraph t, IntMap String) m a)
                           ~R# (forall {a}. IO a -> HeapPrintT t m a))

$cp1MonadState
  = \ @s @t @m $dMonadState ->
      $fMonadHeapPrintT ($p1MonadState $dMonadState)

$fMonadStatesHeapPrintT
  = \ @s @t @m $dMonadState ->
      C:MonadState
        ($cp1MonadState $dMonadState)
        ($cget $dMonadState)
        ($cput $dMonadState)
        ($cstate $dMonadState)

$cp1MonadDecorate
  = \ @t @m $dMonadDecorate2 ->
      $fMonadHeapPrintT ($p1MonadDecorate $dMonadDecorate2)

$fMonadHeapPrinttHeapPrintT
  = \ @m @t $dMonad1 ->
      C:MonadHeapPrint
        ($fMonadHeapPrintT $dMonad1)
        (($cgetHeapBindings $dMonad1)
         `cast` <Co:17> :: ((HeapGraph t, IntMap String)
                            -> m (IntMap String))
                           ~R# HeapPrintT t m (IntMap String))
        (($cgetHeapContent $dMonad1)
         `cast` <Co:17> :: ((HeapGraph t, IntMap String) -> m (HeapGraph t))
                           ~R# HeapPrintT t m (HeapGraph t))

$dmgetHeapContent
  = \ @k @m _ @t @n $d~ $dMonadHeapPrint2 $dMonadTrans ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint2 } in
      case eq_sel $d~ of co { __DEFAULT ->
      (($dMonadTrans
        `cast` <Co:2> :: MonadTrans t
                         ~R# (forall (m :: * -> *) a. Monad m => m a -> t m a))
         $dMonad1 (getHeapContent $dMonadHeapPrint2))
      `cast` <Co:5> :: t n (HeapGraph k) ~R# m (HeapGraph k)
      }

$dmgetHeapBindings
  = \ @k @m _ @t @n $d~ $dMonadHeapPrint2 $dMonadTrans ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint2 } in
      case eq_sel $d~ of co { __DEFAULT ->
      (($dMonadTrans
        `cast` <Co:2> :: MonadTrans t
                         ~R# (forall (m :: * -> *) a. Monad m => m a -> t m a))
         $dMonad1 (getHeapBindings $dMonadHeapPrint2))
      `cast` <Co:5> :: t n (IntMap String) ~R# m (IntMap String)
      }

$cgetHeapBindings1
  = \ @t @m $dMonadHeapPrint1 ->
      let { eta = getHeapBindings $dMonadHeapPrint1 } in
      (\ _ -> eta)
      `cast` <Co:13> :: (IntMap Attr -> m (IntMap String))
                        ~R# DecorateT m (IntMap String)

$cgetHeapContent1
  = \ @t @m $dMonadHeapPrint1 ->
      let { eta = getHeapContent $dMonadHeapPrint1 } in
      (\ _ -> eta)
      `cast` <Co:13> :: (IntMap Attr -> m (HeapGraph t))
                        ~R# DecorateT m (HeapGraph t)

$fMonadHeapPrinttDecorateT
  = \ @t @m $dMonadHeapPrint1 ->
      C:MonadHeapPrint
        ($cp1MonadHeapPrint $dMonadHeapPrint1)
        ($cgetHeapBindings1 $dMonadHeapPrint1)
        ($cgetHeapContent1 $dMonadHeapPrint1)

$dmdecorateMap
  = \ @m _ @t @m' $dMonadTrans $dMonadDecorate3 $d~ ->
      let { $dMonad1 = $p1MonadDecorate $dMonadDecorate3 } in
      case eq_sel $d~ of co { __DEFAULT ->
      (($dMonadTrans
        `cast` <Co:2> :: MonadTrans t
                         ~R# (forall (m :: * -> *) a. Monad m => m a -> t m a))
         $dMonad1 (decorateMap $dMonadDecorate3))
      `cast` <Co:5> :: t m' (IntMap Attr) ~R# m (IntMap Attr)
      }

$cdecorateMap
  = \ @t @m $dMonadDecorate2 ->
      let { eta = decorateMap $dMonadDecorate2 } in
      (\ _ -> eta)
      `cast` <Co:17> :: ((HeapGraph t, IntMap String) -> m (IntMap Attr))
                        ~R# HeapPrintT t m (IntMap Attr)

$fMonadDecorateHeapPrintT
  = \ @t @m $dMonadDecorate2 ->
      C:MonadDecorate
        ($cp1MonadDecorate $dMonadDecorate2)
        ($cdecorateMap $dMonadDecorate2)

unDecorateT1 = \ @m @a ds -> ds

unDecorateT
  = unDecorateT1
    `cast` <Co:13> :: (forall {m :: * -> *} {a}.
                       DecorateT m a -> DecorateT m a)
                      ~R# (forall {m :: * -> *} {a}.
                           DecorateT m a -> ReaderT (IntMap Attr) m a)

unHeapPrintT1 = \ @t @m @a ds -> ds

unHeapPrintT
  = unHeapPrintT1
    `cast` <Co:17> :: (forall {t} {m :: * -> *} {a}.
                       HeapPrintT t m a -> HeapPrintT t m a)
                      ~R# (forall {t} {m :: * -> *} {a}.
                           HeapPrintT t m a -> ReaderT (HeapGraph t, IntMap String) m a)

traverseHeapGraph
  = \ @m @a @b $dApplicative1 eta eta1 ->
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      fmap
        $dFunctor
        ((\ ds -> ds)
         `cast` <Co:8> :: (IntMap (HeapGraphEntry b)
                           -> IntMap (HeapGraphEntry b))
                          ~R# (IntMap (HeapGraphEntry b) -> HeapGraph b))
        (traverse
           $fTraversableIntMap
           $dApplicative1
           eta
           (eta1 `cast` <Co:2> :: HeapGraph a ~R# IntMap (HeapGraphEntry a)))

traverseHeapEntry
  = \ @m @a @b $dApplicative1 eta eta1 ->
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      fmap
        $dFunctor
        (\ x ->
           case eta1 of { HeapGraphEntry ds ds1 ds2 ds3 ->
           HeapGraphEntry ds ds1 ds2 x
           })
        (eta (case eta1 of { HeapGraphEntry ds1 ds2 ds3 ds4 -> ds4 }))

childrenOf
  = \ @t i hg ->
      case lookup
             i (hg `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t))
      of {
        Nothing -> [];
        Just hge ->
          catMaybes
            ($fFoldableGenClosure_$cfoldr
               (\ ds ds1 -> : ds ds1)
               []
               (case hge of { HeapGraphEntry ds1 ds2 ds3 ds4 -> ds2 }))
      }

lookupDecorate
  = \ @m $dMonadDecorate2 ->
      let { $dFunctor = $p1MonadDecorate $dMonadDecorate2 } in
      let { $dFunctor1 = $p1Monad $dFunctor } in
      let { $dFunctor2 = $p1Applicative $dFunctor1 } in
      \ i -> fmap $dFunctor2 (lookup i) (decorateMap $dMonadDecorate2)

runDecorateT1 = \ @m @a ds -> ds

runDecorateT
  = runDecorateT1
    `cast` <Co:19> :: (forall {m :: * -> *} {a}.
                       DecorateT m a -> DecorateT m a)
                      ~R# (forall {m :: * -> *} {a}. DecorateT m a -> IntMap Attr -> m a)

pClos1
  = \ @k @k1 @k2 @t @r @f @x @m $dIP4 $dPrintClosure34 a b ->
      pClosImpl
        $dPrintClosure34
        $dIP4
        (proxy# `cast` <Co:6> :: Proxy# x ~R# (?printLocal::Proxy# x))
        a
        b

pClos
  = pClos1
    `cast` <Co:50> :: (forall {k} {k1} {k2} {t :: k} {r :: k1} {f}
                              {x :: k2} {m :: * -> *}.
                       (?printBase::Proxy# r, PrintClosure r x f m) =>
                       Int -> f -> m (Doc Attr))
                      ~R# (forall {k} {k1} {k2} {t :: k} {r :: k1} {f} {x :: k2}
                                  {m :: * -> *}.
                           (?printBase::Proxy# r, PrintClosure r x f m) =>
                           Int -> f -> Dispatch t r x (m (Doc Attr)))

printClosure1
  = \ @k @r @f @m $dPrintClosure34 prec f1 ->
      self2
        ((pClos1
            (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printBase::Proxy# r))
            $dPrintClosure34
            prec
            f1)
         `cast` <Co:14> :: m (Doc Attr) ~R# Dispatch Any r r (m (Doc Attr)))

printClosure
  = printClosure1
    `cast` <Co:37> :: (forall {k} {r :: k} {f} {m :: * -> *}.
                       PrintClosure r r f m =>
                       Int -> f -> Dispatch Any r r (m (Doc Attr)))
                      ~R# (forall {k} {r :: k} {f} {m :: * -> *}.
                           PrintClosure r r f m =>
                           Int -> f -> m (Doc Attr))

$cpClosImpl1
  = \ @k @r @t @m $dPrintClosure34 $dMonadHeapPrint1 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec ds ->
        case ds of { HeapKV ds1 s t1 ->
        fmap
          $dFunctor
          (\ p ->
             vcat_$c<>
               ($fPrettyChar_$cprettyList s)
               (vcat_$c<> (list_$cfromString (unpackCString# " = "#)) p))
          ((self2
              ((pClosImpl
                  $dPrintClosure34
                  $dIP4
                  (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                  prec
                  t1)
               `cast` <Co:14> :: m (Doc Attr)
                                 ~R# Dispatch Any r r (m (Doc Attr))))
           `cast` <Co:13> :: Dispatch Any r r (m (Doc Attr)) ~R# m (Doc Attr))
        }

$fPrintClosurekTYPErBaseHeapKVm
  = \ @k @r @t @m $dPrintClosure34 $dMonadHeapPrint1 ->
      C:PrintClosure
        ($cp1PrintClosure6 $dPrintClosure34 $dMonadHeapPrint1)
        ($cpClosImpl1 $dPrintClosure34 $dMonadHeapPrint1)

$fPrintClosurekTYPErDecorateElemsbm
  = \ @k @k1 @r @x @b @m $dPrintClosure34 $dMonadDecorate2 ->
      C:PrintClosure
        ($cp1PrintClosure2 $dPrintClosure34 $dMonadDecorate2)
        ((\ $dIP4 _ prec idx ->
            super2
              ((pClos1 $dIP4 $dPrintClosure34 prec idx)
               `cast` <Co:13> :: m (Doc Attr)
                                 ~R# Dispatch (DecorateElems x) r x (m (Doc Attr))))
         `cast` <Co:34> :: ((?printBase::Proxy# r,
                             ?printLocal::Proxy# (DecorateElems x)) =>
                            Int -> b -> Dispatch (DecorateElems x) r x (m (Doc Attr)))
                           ~R# ((?printBase::Proxy# r,
                                 ?printLocal::Proxy# (DecorateElems x)) =>
                                Int -> b -> m (Doc Attr)))

$cpClosImpl2
  = \ @k @k1 @r @x @m $dPrintClosure34 $dMonadDecorate2 ->
      let { $dMonad1 = $p1MonadDecorate $dMonadDecorate2 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec idx ->
        >>=
          $dMonad1
          (lookupDecorate $dMonadDecorate2 idx)
          (\ ds ->
             case ds of {
               Nothing ->
                 (super2
                    ((pClos1 $dIP4 $dPrintClosure34 prec idx)
                     `cast` <Co:13> :: m (Doc Attr)
                                       ~R# Dispatch (DecorateElems x) r x (m (Doc Attr))))
                 `cast` <Co:12> :: Dispatch (DecorateElems x) r x (m (Doc Attr))
                                   ~R# m (Doc Attr);
               Just dec ->
                 fmap
                   $dFunctor
                   (annotate dec)
                   ((super2
                       ((pClosImpl
                           $dPrintClosure34
                           $dIP4
                           (proxy# `cast` <Co:6> :: Proxy# x ~R# (?printLocal::Proxy# x))
                           prec
                           idx)
                        `cast` <Co:13> :: m (Doc Attr)
                                          ~R# Dispatch (DecorateElems x) r x (m (Doc Attr))))
                    `cast` <Co:12> :: Dispatch (DecorateElems x) r x (m (Doc Attr))
                                      ~R# m (Doc Attr))
             })

$fPrintClosurekTYPErDecorateElemsIntm
  = \ @k @k1 @r @x @m $dPrintClosure34 $dMonadDecorate2 ->
      C:PrintClosure
        ($cp1PrintClosure1 $dPrintClosure34 $dMonadDecorate2)
        ($cpClosImpl2 $dPrintClosure34 $dMonadDecorate2)

$cpClosImpl3
  = \ @k @k1 @m @r @f @t $dMonadDecorate2 $dPrintClosure34 ->
      let { $dMonad1 = $p1MonadDecorate $dMonadDecorate2 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec v ->
        case v of wild { HeapKV idx ds ds1 ->
        >>=
          $dMonad1
          (lookupDecorate $dMonadDecorate2 idx)
          (\ ds2 ->
             case ds2 of {
               Nothing ->
                 (super2
                    ((pClosImpl
                        $dPrintClosure34
                        $dIP4
                        (proxy# `cast` <Co:6> :: Proxy# f ~R# (?printLocal::Proxy# f))
                        prec
                        wild)
                     `cast` <Co:13> :: m (Doc Attr)
                                       ~R# Dispatch (DecorateElems f) r f (m (Doc Attr))))
                 `cast` <Co:12> :: Dispatch (DecorateElems f) r f (m (Doc Attr))
                                   ~R# m (Doc Attr);
               Just dec ->
                 fmap
                   $dFunctor
                   (annotate dec)
                   ((super2
                       ((pClosImpl
                           $dPrintClosure34
                           $dIP4
                           (proxy# `cast` <Co:6> :: Proxy# f ~R# (?printLocal::Proxy# f))
                           prec
                           wild)
                        `cast` <Co:13> :: m (Doc Attr)
                                          ~R# Dispatch (DecorateElems f) r f (m (Doc Attr))))
                    `cast` <Co:12> :: Dispatch (DecorateElems f) r f (m (Doc Attr))
                                      ~R# m (Doc Attr))
             })
        }

$fPrintClosurekTYPErDecorateElemsHeapKVm
  = \ @k @k1 @m @r @f @t $dMonadDecorate2 $dPrintClosure34 ->
      C:PrintClosure
        ($cp1PrintClosure $dMonadDecorate2 $dPrintClosure34)
        ($cpClosImpl3 $dMonadDecorate2 $dPrintClosure34)

$cpClosImpl4
  = \ @k @k1 @k2 @r @f @s @m @t $dPrintClosure34 $dIP4 _ prec c ->
      super2
        ((pClos1 $dIP4 $dPrintClosure34 prec c)
         `cast` <Co:15> :: m (Doc Attr)
                           ~R# Dispatch (Elide t f) r f (m (Doc Attr)))

$fPrintClosurekTYPErElidesm
  = \ @k @k1 @k2 @r @f @s @m @t $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        (($cpClosImpl4 $dPrintClosure34)
         `cast` <Co:38> :: ((?printBase::Proxy# r,
                             ?printLocal::Proxy# (Elide t f)) =>
                            Int -> s -> Dispatch (Elide t f) r f (m (Doc Attr)))
                           ~R# ((?printBase::Proxy# r, ?printLocal::Proxy# (Elide t f)) =>
                                Int -> s -> m (Doc Attr)))

$cpClosImpl5
  = \ @k @k1 @r @f @b @m $dPrintClosure34 $dIP4 _ p f1 ->
      super2
        ((pClos1 $dIP4 $dPrintClosure34 p f1)
         `cast` <Co:13> :: m (Doc Attr)
                           ~R# Dispatch (PrettyText f) r f (m (Doc Attr)))

$fPrintClosurekTYPErPrettyTextbm
  = \ @k @k1 @r @f @b @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        (($cpClosImpl5 $dPrintClosure34)
         `cast` <Co:34> :: ((?printBase::Proxy# r,
                             ?printLocal::Proxy# (PrettyText f)) =>
                            Int -> b -> Dispatch (PrettyText f) r f (m (Doc Attr)))
                           ~R# ((?printBase::Proxy# r, ?printLocal::Proxy# (PrettyText f)) =>
                                Int -> b -> m (Doc Attr)))

$cpClosImpl6
  = \ @k @k1 @r @f @b @m $dPrintClosure34 $dIP4 _ p f1 ->
      super2
        ((pClos1 $dIP4 $dPrintClosure34 p f1)
         `cast` <Co:13> :: m (Doc Attr)
                           ~R# Dispatch (PrettyListLiterals f) r f (m (Doc Attr)))

$fPrintClosurekTYPErPrettyListLiteralsbm
  = \ @k @k1 @r @f @b @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        (($cpClosImpl6 $dPrintClosure34)
         `cast` <Co:34> :: ((?printBase::Proxy# r,
                             ?printLocal::Proxy# (PrettyListLiterals f)) =>
                            Int -> b -> Dispatch (PrettyListLiterals f) r f (m (Doc Attr)))
                           ~R# ((?printBase::Proxy# r,
                                 ?printLocal::Proxy# (PrettyListLiterals f)) =>
                                Int -> b -> m (Doc Attr)))

$cpClosImpl7
  = \ @k @r @x @m $dPrintClosure34 eta _ eta2 eta3 ->
      let { $dApplicative1 = $p1PrintClosure $dPrintClosure34 } in
      case eta3 of {
        Nothing ->
          pure $dApplicative1 (list_$cfromString (unpackCString# "..."#));
        Just i ->
          (self2
             ((pClos1 eta $dPrintClosure34 eta2 i)
              `cast` <Co:14> :: m (Doc Attr)
                                ~R# Dispatch Any r r (m (Doc Attr))))
          `cast` <Co:13> :: Dispatch Any r r (m (Doc Attr)) ~R# m (Doc Attr)
      }

$fPrintClosurekTYPErBaseMaybem
  = \ @k @r @x @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34) ($cpClosImpl7 $dPrintClosure34)

$cpClosImpl8
  = \ @k @r @m $dPrintClosure34 $dIP4 _ prec hge ->
      self2
        (let {
           b = case hge of { HeapGraphEntry ds1 ds2 ds3 ds4 -> ds2 } } in
         (pClosImpl
            $dPrintClosure34
            $dIP4
            (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
            prec
            b)
         `cast` <Co:14> :: m (Doc Attr) ~R# Dispatch Any r r (m (Doc Attr)))

$fPrintClosurekTYPErBaseHeapGraphEntrym
  = \ @k @r @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        (($cpClosImpl8 $dPrintClosure34)
         `cast` <Co:34> :: ((?printBase::Proxy# r,
                             ?printLocal::Proxy# Base) =>
                            Int -> HeapGraphEntry HeapData -> Dispatch Any r r (m (Doc Attr)))
                           ~R# ((?printBase::Proxy# r, ?printLocal::Proxy# Base) =>
                                Int -> HeapGraphEntry HeapData -> m (Doc Attr)))

$cpClosImpl9
  = \ @k @k1 @r @f @b @m $dPrintClosure34 $dIP4 _ p f1 ->
      super2
        ((pClos1 $dIP4 $dPrintClosure34 p f1)
         `cast` <Co:13> :: m (Doc Attr)
                           ~R# Dispatch (NamedThunks f) r f (m (Doc Attr)))

$fPrintClosurekTYPErNamedThunksbm
  = \ @k @k1 @r @f @b @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        (($cpClosImpl9 $dPrintClosure34)
         `cast` <Co:34> :: ((?printBase::Proxy# r,
                             ?printLocal::Proxy# (NamedThunks f)) =>
                            Int -> b -> Dispatch (NamedThunks f) r f (m (Doc Attr)))
                           ~R# ((?printBase::Proxy# r, ?printLocal::Proxy# (NamedThunks f)) =>
                                Int -> b -> m (Doc Attr)))

isNil
  = \ @b ds ->
      case ds of {
        __DEFAULT -> False;
        ConstrClosure ds1 ds2 ds3 ds4 ds5 ds6 ->
          case eqString ds6 (unpackCString# "[]"#) of {
            False -> False;
            True ->
              case ds3 of {
                [] ->
                  case ds2 of {
                    [] -> True;
                    : ipv ipv1 -> False
                  };
                : ipv ipv1 -> False
              }
          }
      }

addBraces
  = \ @s $dMonoid $dIsString eta eta1 ->
      let { $dSemigroup = $p1Monoid $dMonoid } in
      case eta of {
        False -> eta1;
        True ->
          <>
            $dSemigroup
            (($dIsString `cast` <Co:2> :: IsString s ~R# (String -> s))
               (unpackCString# "("#))
            (<>
               $dSemigroup
               eta1
               (($dIsString `cast` <Co:2> :: IsString s ~R# (String -> s))
                  (unpackCString# ")"#)))
      }

app
  = \ @ann ds ds1 ->
      case ds1 of wild {
        [] ->
          addBraces
            $fMonoidDoc
            (list_$cfromString
             `cast` <Co:4> :: (String -> Doc ann) ~R# IsString (Doc ann))
            (case ds of { I# y -> tagToEnum# (<=# 10# y) })
            (sep []);
        : a ds2 ->
          case ds2 of {
            [] -> vcat_$c<> a (list_$cfromString (unpackCString# "()"#));
            : ipv ipv1 ->
              addBraces
                $fMonoidDoc
                (list_$cfromString
                 `cast` <Co:4> :: (String -> Doc ann) ~R# IsString (Doc ann))
                (case ds of { I# y -> tagToEnum# (<=# 10# y) })
                (sep wild)
          }
      }

$cpClosImpl10
  = \ @k @k1 @r @m @f $dPrintClosure34 $dPrintClosure35 ->
      let { $dApplicative1 = $p1PrintClosure $dPrintClosure34 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec hge ->
        case hge of wild { HeapGraphEntry ds1 ds2 ds3 ds4 ->
        case ds2 of {
          __DEFAULT ->
            (super2
               ((pClosImpl
                   $dPrintClosure35
                   $dIP4
                   (proxy# `cast` <Co:6> :: Proxy# f ~R# (?printLocal::Proxy# f))
                   prec
                   wild)
                `cast` <Co:13> :: m (Doc Attr)
                                  ~R# Dispatch (NamedThunks f) r f (m (Doc Attr))))
            `cast` <Co:12> :: Dispatch (NamedThunks f) r f (m (Doc Attr))
                              ~R# m (Doc Attr);
          FunClosure ds ds7 ds8 ->
            case ds4 of { HeapData ds9 ds10 ->
            case ds9 of {
              Nothing ->
                (super2
                   ((pClosImpl
                       $dPrintClosure35
                       $dIP4
                       (proxy# `cast` <Co:6> :: Proxy# f ~R# (?printLocal::Proxy# f))
                       prec
                       wild)
                    `cast` <Co:13> :: m (Doc Attr)
                                      ~R# Dispatch (NamedThunks f) r f (m (Doc Attr))))
                `cast` <Co:12> :: Dispatch (NamedThunks f) r f (m (Doc Attr))
                                  ~R# m (Doc Attr);
              Just ds11 ->
                case ds11 of { From ds12 ds13 ds14 ds15 ds16 ds17 ->
                fmap
                  $dFunctor
                  (\ ptrs ->
                     app
                       prec
                       (: (viaShow_$cpretty ds12)
                          (++ ptrs (map $fPrettyWord_$cpretty ds8))))
                  (traverse
                     $fTraversable[]
                     $dApplicative1
                     (let { a = I# 10# } in
                      (\ x ->
                         self2
                           ((pClosImpl
                               $dPrintClosure34
                               $dIP4
                               (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                               a
                               x)
                            `cast` <Co:14> :: m (Doc Attr)
                                              ~R# Dispatch Any r r (m (Doc Attr))))
                      `cast` <Co:17> :: (Maybe HeapGraphIndex
                                         -> Dispatch Any r r (m (Doc Attr)))
                                        ~R# (Maybe HeapGraphIndex -> m (Doc Attr)))
                     ds7)
                }
            }
            };
          ThunkClosure ds ds7 ds8 ->
            case ds4 of { HeapData ds9 ds10 ->
            case ds9 of {
              Nothing ->
                (super2
                   ((pClosImpl
                       $dPrintClosure35
                       $dIP4
                       (proxy# `cast` <Co:6> :: Proxy# f ~R# (?printLocal::Proxy# f))
                       prec
                       wild)
                    `cast` <Co:13> :: m (Doc Attr)
                                      ~R# Dispatch (NamedThunks f) r f (m (Doc Attr))))
                `cast` <Co:12> :: Dispatch (NamedThunks f) r f (m (Doc Attr))
                                  ~R# m (Doc Attr);
              Just ds11 ->
                case ds11 of { From ds12 ds13 ds14 ds15 ds16 ds17 ->
                fmap
                  $dFunctor
                  (\ ptrs ->
                     app
                       prec
                       (: (viaShow_$cpretty ds12)
                          (++ ptrs (map $fPrettyWord_$cpretty ds8))))
                  (traverse
                     $fTraversable[]
                     $dApplicative1
                     (let { a = I# 10# } in
                      (\ x ->
                         self2
                           ((pClosImpl
                               $dPrintClosure34
                               $dIP4
                               (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                               a
                               x)
                            `cast` <Co:14> :: m (Doc Attr)
                                              ~R# Dispatch Any r r (m (Doc Attr))))
                      `cast` <Co:17> :: (Maybe HeapGraphIndex
                                         -> Dispatch Any r r (m (Doc Attr)))
                                        ~R# (Maybe HeapGraphIndex -> m (Doc Attr)))
                     ds7)
                }
            }
            }
        }
        }

$fPrintClosurekTYPErNamedThunksHeapGraphEntrym
  = \ @k @k1 @r @m @f $dPrintClosure34 $dPrintClosure35 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34)
        ($cpClosImpl10 $dPrintClosure34 $dPrintClosure35)

braceize
  = \ @a ds ->
      case ds of wild {
        [] -> list_$cfromString [];
        : ipv ipv1 -> braces (hsep (punctuate comma wild))
      }

$dIP
  = pushCallStack
      (unpackCString# "tail"#,
       SrcLoc
         (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
         (unpackCString# "HeapUtils"#)
         (unpackCString# "src/HeapUtils.hs"#)
         (I# 312#)
         (I# 21#)
         (I# 312#)
         (I# 25#))
      emptyCallStack

$dIP1
  = pushCallStack
      (unpackCString# "last"#,
       SrcLoc
         (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
         (unpackCString# "HeapUtils"#)
         (unpackCString# "src/HeapUtils.hs"#)
         (I# 311#)
         (I# 28#)
         (I# 311#)
         (I# 32#))
      emptyCallStack

$dIP2
  = pushCallStack
      (unpackCString# "head"#,
       SrcLoc
         (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
         (unpackCString# "HeapUtils"#)
         (unpackCString# "src/HeapUtils.hs"#)
         (I# 311#)
         (I# 8#)
         (I# 311#)
         (I# 12#))
      emptyCallStack

isTup
  = \ @b ds ->
      case ds of {
        __DEFAULT -> Nothing;
        ConstrClosure ds1 ds2 ds3 ds4 ds5 ds6 ->
          case ds3 of {
            [] ->
              case $wlenAcc ds6 0# of ww { __DEFAULT ->
              case tagToEnum# (>=# ww 3#) of {
                False -> Nothing;
                True ->
                  case ds6 of wild3 {
                    [] ->
                      case head1
                             ($dIP2 `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
                      of wild4 {
                      };
                    : x ds7 ->
                      case x of wild4 { C# x1 ->
                      case x1 of {
                        __DEFAULT -> Nothing;
                        '('# ->
                          letrec {
                            go1
                              = \ ds8 eta ->
                                  case ds8 of {
                                    [] -> eta;
                                    : y ys -> go1 ys y
                                  }; } in
                          case go1
                                 wild3
                                 (case $dIP1 of wild6 {
                                    __DEFAULT ->
                                      lastError
                                        ((PushCallStack
                                            (unpackFoldrCString#
                                               "lastError"# (\ ds8 ds9 -> : ds8 ds9) [])
                                            (SrcLoc
                                               (unpackFoldrCString#
                                                  "base"# (\ ds8 ds9 -> : ds8 ds9) [])
                                               (unpackFoldrCString#
                                                  "GHC.List"# (\ ds8 ds9 -> : ds8 ds9) [])
                                               (unpackFoldrCString#
                                                  "libraries/base/GHC/List.hs"#
                                                  (\ ds8 ds9 -> : ds8 ds9)
                                                  [])
                                               (I# 151#)
                                               (I# 29#)
                                               (I# 151#)
                                               (I# 38#))
                                            wild6)
                                         `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack));
                                    FreezeCallStack ds8 ->
                                      lastError
                                        (wild6
                                         `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
                                  })
                          of
                          { C# x2 ->
                          case x2 of {
                            __DEFAULT -> Nothing;
                            ')'# ->
                              letrec {
                                go2
                                  = \ ds8 ->
                                      case ds8 of {
                                        [] -> True `cast` <Co:2> :: Bool ~R# All;
                                        : y ys ->
                                          case y `cast` <Co:1> :: All ~R# Bool of {
                                            False -> False `cast` <Co:2> :: Bool ~R# All;
                                            True -> go2 ys
                                          }
                                      }; } in
                              case (go2
                                      (letrec {
                                         go3
                                           = \ ds8 ->
                                               case ds8 of {
                                                 [] -> [];
                                                 : y ys ->
                                                   : (case y of { C# x3 ->
                                                      case x3 of {
                                                        __DEFAULT ->
                                                          False `cast` <Co:2> :: Bool ~R# All;
                                                        ','# -> True `cast` <Co:2> :: Bool ~R# All
                                                      }
                                                      })
                                                     (go3 ys)
                                               }; } in
                                       go3
                                         (case init1 wild4 ds7 of {
                                            [] ->
                                              lvl
                                                ($dIP
                                                 `cast` <Co:4> :: CallStack
                                                                  ~R# (?callStack::CallStack));
                                            : ds8 xs -> xs
                                          })))
                                   `cast` <Co:1> :: All ~R# Bool
                              of {
                                False -> Nothing;
                                True -> Just ds2
                              }
                          }
                          }
                      }
                      }
                  }
              }
              };
            : ipv ipv1 -> Nothing
          }
      }

$cpClosImpl11
  = \ @k @r @b @m $dPrintClosure34 ->
      let { $dApplicative1 = $p1PrintClosure $dPrintClosure34 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec c ->
        let {
          shorten
            = \ @a $dIsString xs ->
                case $wlenAcc xs 0# of ww { __DEFAULT ->
                case tagToEnum# (># ww 20#) of {
                  False -> xs;
                  True ->
                    ++
                      ($wunsafeTake 20# xs)
                      (: (($dIsString `cast` <Co:2> :: IsString a ~R# (String -> a))
                            (unpackCString# "(and more)"#))
                         [])
                }
                } } in
        join {
          appBox str sel
            = fmap
                $dFunctor
                (\ s -> app prec (: str (: s [])))
                (let { i' = I# 10# } in
                 (self2
                    ((pClosImpl
                        $dPrintClosure34
                        $dIP4
                        (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                        i'
                        sel)
                     `cast` <Co:14> :: m (Doc Attr)
                                       ~R# Dispatch Any r r (m (Doc Attr))))
                 `cast` <Co:13> :: Dispatch Any r r (m (Doc Attr))
                                   ~R# m (Doc Attr)) } in
        case isChar c of {
          Nothing ->
            case isCons c of {
              Nothing ->
                case isTup c of {
                  Nothing ->
                    case c of {
                      ConstrClosure ds ds1 ds2 ds3 ds4 ds5 ->
                        fmap
                          $dFunctor
                          (\ ptrs ->
                             app
                               prec
                               (: ($fPrettyChar_$cprettyList ds5)
                                  (++ ptrs (map $fPrettyWord_$cpretty ds2))))
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              (\ v' ->
                                 self2
                                   ((pClosImpl
                                       $dPrintClosure34
                                       $dIP4
                                       (proxy#
                                        `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                       i'
                                       v')
                                    `cast` <Co:14> :: m (Doc Attr)
                                                      ~R# Dispatch Any r r (m (Doc Attr))))
                              `cast` <Co:16> :: (b -> Dispatch Any r r (m (Doc Attr)))
                                                ~R# (b -> m (Doc Attr)))
                             ds1);
                      FunClosure ds ds1 ds2 ->
                        fmap
                          $dFunctor
                          (\ ptrs ->
                             vcat_$c<>
                               (list_$cfromString (unpackCString# "_fun"#))
                               (let { ds3 = ++ ptrs (map $fPrettyWord_$cpretty ds2) } in
                                case ds3 of wild4 {
                                  [] -> list_$cfromString [];
                                  : ipv ipv1 -> braces (hsep (punctuate comma wild4))
                                }))
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 0# } in
                              (\ v' ->
                                 self2
                                   ((pClosImpl
                                       $dPrintClosure34
                                       $dIP4
                                       (proxy#
                                        `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                       i'
                                       v')
                                    `cast` <Co:14> :: m (Doc Attr)
                                                      ~R# Dispatch Any r r (m (Doc Attr))))
                              `cast` <Co:16> :: (b -> Dispatch Any r r (m (Doc Attr)))
                                                ~R# (b -> m (Doc Attr)))
                             ds1);
                      ThunkClosure ds ds1 ds2 ->
                        fmap
                          $dFunctor
                          (\ ptrs ->
                             app
                               prec
                               (: (list_$cfromString (unpackCString# "_thunk"#))
                                  (++ ptrs (map $fPrettyWord_$cpretty ds2))))
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              (\ v' ->
                                 self2
                                   ((pClosImpl
                                       $dPrintClosure34
                                       $dIP4
                                       (proxy#
                                        `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                       i'
                                       v')
                                    `cast` <Co:14> :: m (Doc Attr)
                                                      ~R# Dispatch Any r r (m (Doc Attr))))
                              `cast` <Co:16> :: (b -> Dispatch Any r r (m (Doc Attr)))
                                                ~R# (b -> m (Doc Attr)))
                             ds1);
                      SelectorClosure ds ds1 ->
                        jump appBox (list_$cfromString (unpackCString# "_sel"#)) ds1;
                      PAPClosure ds bx bx1 ds1 ds2 ->
                        fmap
                          $dFunctor
                          (app prec)
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              (\ v' ->
                                 self2
                                   ((pClosImpl
                                       $dPrintClosure34
                                       $dIP4
                                       (proxy#
                                        `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                       i'
                                       v')
                                    `cast` <Co:14> :: m (Doc Attr)
                                                      ~R# Dispatch Any r r (m (Doc Attr))))
                              `cast` <Co:16> :: (b -> Dispatch Any r r (m (Doc Attr)))
                                                ~R# (b -> m (Doc Attr)))
                             (: ds1 ds2));
                      APClosure ds bx bx1 ds1 ds2 ->
                        fmap
                          $dFunctor
                          (app prec)
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              (\ v' ->
                                 self2
                                   ((pClosImpl
                                       $dPrintClosure34
                                       $dIP4
                                       (proxy#
                                        `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                       i'
                                       v')
                                    `cast` <Co:14> :: m (Doc Attr)
                                                      ~R# Dispatch Any r r (m (Doc Attr))))
                              `cast` <Co:16> :: (b -> Dispatch Any r r (m (Doc Attr)))
                                                ~R# (b -> m (Doc Attr)))
                             (: ds1 ds2));
                      APStackClosure ds ds1 ds2 ->
                        fmap
                          $dFunctor
                          (app prec)
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              (\ v' ->
                                 self2
                                   ((pClosImpl
                                       $dPrintClosure34
                                       $dIP4
                                       (proxy#
                                        `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                       i'
                                       v')
                                    `cast` <Co:14> :: m (Doc Attr)
                                                      ~R# Dispatch Any r r (m (Doc Attr))))
                              `cast` <Co:16> :: (b -> Dispatch Any r r (m (Doc Attr)))
                                                ~R# (b -> m (Doc Attr)))
                             (: ds1 ds2));
                      IndClosure ds ds1 ->
                        jump appBox (list_$cfromString (unpackCString# "_ind"#)) ds1;
                      BCOClosure ds ds1 ds2 ds3 bx bx1 ds4 ->
                        jump appBox (list_$cfromString (unpackCString# "_bco"#)) ds3;
                      BlackholeClosure ds ds1 ->
                        jump appBox (list_$cfromString (unpackCString# "_bh"#)) ds1;
                      ArrWordsClosure ds bx ds1 ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: (list_$cfromString (unpackCString# "toArray"#))
                                (: (vcat_$c<>
                                      (list_$cfromString (unpackCString# "("#))
                                      (vcat_$c<>
                                         ($fPrettyInt_$cpretty
                                            (case $wlenAcc ds1 0# of ww { __DEFAULT -> I# ww }))
                                         (list_$cfromString (unpackCString# " words)"#))))
                                   (: (sep
                                         (punctuate
                                            comma
                                            (shorten
                                               (list_$cfromString
                                                `cast` <Co:4> :: (String -> Doc Attr)
                                                                 ~R# IsString (Doc Attr))
                                               (map $fPrettyWord_$cpretty ds1))))
                                      []))));
                      MutArrClosure ds bx bx1 ds1 ->
                        fmap
                          $dFunctor
                          (\ payload ->
                             list
                               (shorten
                                  (list_$cfromString
                                   `cast` <Co:4> :: (String -> Doc Attr) ~R# IsString (Doc Attr))
                                  payload))
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              (\ v' ->
                                 self2
                                   ((pClosImpl
                                       $dPrintClosure34
                                       $dIP4
                                       (proxy#
                                        `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                       i'
                                       v')
                                    `cast` <Co:14> :: m (Doc Attr)
                                                      ~R# Dispatch Any r r (m (Doc Attr))))
                              `cast` <Co:16> :: (b -> Dispatch Any r r (m (Doc Attr)))
                                                ~R# (b -> m (Doc Attr)))
                             ds1);
                      SmallMutArrClosure ds bx ds1 ->
                        fmap
                          $dFunctor
                          (\ payload ->
                             list
                               (shorten
                                  (list_$cfromString
                                   `cast` <Co:4> :: (String -> Doc Attr) ~R# IsString (Doc Attr))
                                  payload))
                          (traverse
                             $fTraversable[]
                             $dApplicative1
                             (let { i' = I# 10# } in
                              (\ v' ->
                                 self2
                                   ((pClosImpl
                                       $dPrintClosure34
                                       $dIP4
                                       (proxy#
                                        `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                       i'
                                       v')
                                    `cast` <Co:14> :: m (Doc Attr)
                                                      ~R# Dispatch Any r r (m (Doc Attr))))
                              `cast` <Co:16> :: (b -> Dispatch Any r r (m (Doc Attr)))
                                                ~R# (b -> m (Doc Attr)))
                             ds1);
                      MVarClosure ds ds1 ds2 ds3 ->
                        jump appBox (list_$cfromString (unpackCString# "MVar"#)) ds3;
                      IOPortClosure ds ds1 ds2 ds3 ->
                        pure
                          $dApplicative1
                          (list_$cfromString (unpackCString# "_ioPortClosure"#));
                      MutVarClosure ds ds1 ->
                        jump appBox (list_$cfromString (unpackCString# "_mutVar"#)) ds1;
                      BlockingQueueClosure ds ds1 ds2 ds3 ds4 ->
                        pure
                          $dApplicative1
                          (list_$cfromString (unpackCString# "_blockingQueue"#));
                      WeakClosure ds ds1 ds2 ds3 ds4 ds5 ->
                        pure $dApplicative1 (list_$cfromString (unpackCString# "_weak"#));
                      TSOClosure ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 bx bx1 bx2 bx3
                                 bx4 ds10 ->
                        pure
                          $dApplicative1 (list_$cfromString (unpackCString# "_tsoClosure"#));
                      StackClosure ds bx bx1 bx2 ->
                        pure
                          $dApplicative1
                          (list_$cfromString (unpackCString# "_stackClosure"#));
                      IntClosure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: (list_$cfromString (unpackCString# "Int"#))
                                (: ($fPrettyInt_$cpretty (I# bx)) [])));
                      WordClosure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: (list_$cfromString (unpackCString# "Word"#))
                                (: ($fPrettyWord_$cpretty (W# bx)) [])));
                      Int64Closure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: (list_$cfromString (unpackCString# "Int64"#))
                                (: ($fPrettyInt64_$cpretty (I64# bx)) [])));
                      Word64Closure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: (list_$cfromString (unpackCString# "Word64"#))
                                (: ($fPrettyWord64_$cpretty (W64# bx)) [])));
                      AddrClosure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: (list_$cfromString (unpackCString# "Addr"#))
                                (: ($fPrettyInt_$cpretty (I# bx)) [])));
                      FloatClosure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: (list_$cfromString (unpackCString# "Float"#))
                                (: ($fPrettyFloat_$cpretty (F# bx)) [])));
                      DoubleClosure ds bx ->
                        pure
                          $dApplicative1
                          (app
                             prec
                             (: (list_$cfromString (unpackCString# "Double"#))
                                (: ($fPrettyDouble_$cpretty (D# bx)) [])));
                      OtherClosure ds ds1 ds2 ->
                        pure $dApplicative1 (list_$cfromString (unpackCString# "_other"#));
                      UnsupportedClosure ds ->
                        pure
                          $dApplicative1
                          (list_$cfromString (unpackCString# "_unsupported closure"#))
                    };
                  Just vs ->
                    fmap
                      $dFunctor
                      tupled
                      (traverse
                         $fTraversable[]
                         $dApplicative1
                         (let { i' = I# 1# } in
                          (\ v' ->
                             self2
                               ((pClosImpl
                                   $dPrintClosure34
                                   $dIP4
                                   (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                   i'
                                   v')
                                `cast` <Co:14> :: m (Doc Attr)
                                                  ~R# Dispatch Any r r (m (Doc Attr))))
                          `cast` <Co:16> :: (b -> Dispatch Any r r (m (Doc Attr)))
                                            ~R# (b -> m (Doc Attr)))
                         vs)
                };
              Just ds ->
                case ds of { (h, t) ->
                fmap
                  $dFunctor
                  (addBraces
                     $fMonoidDoc
                     (list_$cfromString
                      `cast` <Co:4> :: (String -> Doc Attr) ~R# IsString (Doc Attr))
                     (case prec of { I# y -> tagToEnum# (<=# 5# y) }))
                  (<*>
                     $dApplicative1
                     (fmap
                        $dFunctor
                        (\ l r1 ->
                           vcat_$c<>
                             l (vcat_$c<> (list_$cfromString (unpackCString# " : "#)) r1))
                        (let { i' = I# 5# } in
                         (self2
                            ((pClosImpl
                                $dPrintClosure34
                                $dIP4
                                (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                i'
                                h)
                             `cast` <Co:14> :: m (Doc Attr)
                                               ~R# Dispatch Any r r (m (Doc Attr))))
                         `cast` <Co:13> :: Dispatch Any r r (m (Doc Attr))
                                           ~R# m (Doc Attr)))
                     (let { i' = I# 4# } in
                      (self2
                         ((pClosImpl
                             $dPrintClosure34
                             $dIP4
                             (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                             i'
                             t)
                          `cast` <Co:14> :: m (Doc Attr)
                                            ~R# Dispatch Any r r (m (Doc Attr))))
                      `cast` <Co:13> :: Dispatch Any r r (m (Doc Attr))
                                        ~R# m (Doc Attr)))
                }
            };
          Just ch ->
            pure
              $dApplicative1
              (app
                 prec
                 (: (list_$cfromString (unpackCString# "C#"#))
                    (: (case ch of { C# ds1 ->
                        case ds1 of ds2 {
                          __DEFAULT -> Char ds2;
                          '\n'# -> line
                        }
                        })
                       [])))
        }

$fPrintClosurekTYPErBaseGenClosurem
  = \ @k @r @b @m $dPrintClosure34 ->
      C:PrintClosure
        ($p1PrintClosure $dPrintClosure34) ($cpClosImpl11 $dPrintClosure34)

lookupBindingLabel
  = \ @t @m $dMonadHeapPrint1 ->
      let { $dFunctor = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dFunctor1 = $p1Monad $dFunctor } in
      let { $dFunctor2 = $p1Applicative $dFunctor1 } in
      \ i ->
        fmap $dFunctor2 (lookup i) (getHeapBindings $dMonadHeapPrint1)

lookupHeapClosure
  = \ @t @m $dMonadHeapPrint1 ->
      let {
        $dIP4
          = pushCallStack
              (unpackCString# "fromJust"#,
               SrcLoc
                 (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
                 (unpackCString# "HeapUtils"#)
                 (unpackCString# "src/HeapUtils.hs"#)
                 (I# 339#)
                 (I# 23#)
                 (I# 339#)
                 (I# 31#))
              emptyCallStack } in
      let { $dFunctor = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dFunctor1 = $p1Monad $dFunctor } in
      let { $dFunctor2 = $p1Applicative $dFunctor1 } in
      \ i ->
        fmap
          $dFunctor2
          (let {
             f = fromJust
                   ($dIP4 `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack)) } in
           \ x ->
             f (lookup
                  i (x `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t))))
          (getHeapContent $dMonadHeapPrint1)

lookupHeapRep
  = \ @t @m $dMonadHeapPrint1 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ i ->
        >>=
          $dMonad1
          (lookupBindingLabel $dMonadHeapPrint1 i)
          (\ ds ->
             case ds of {
               Nothing ->
                 fmap
                   $dFunctor
                   (\ ds1 -> Right ds1)
                   (lookupHeapClosure $dMonadHeapPrint1 i);
               Just o -> pure $dApplicative1 (Left o)
             })

$cpClosImpl12
  = \ @k @b @m @r $dMonadHeapPrint1 $dPrintClosure34 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      \ $dIP4 _ r1 i ->
        >>=
          $dMonad1
          (lookupHeapRep $dMonadHeapPrint1 i)
          (\ ds ->
             case ds of {
               Left l -> pure $dApplicative1 ($fPrettyChar_$cprettyList l);
               Right e ->
                 (self2
                    ((pClos1 $dIP4 $dPrintClosure34 r1 e)
                     `cast` <Co:14> :: m (Doc Attr)
                                       ~R# Dispatch Any r r (m (Doc Attr))))
                 `cast` <Co:13> :: Dispatch Any r r (m (Doc Attr)) ~R# m (Doc Attr)
             })

$fPrintClosurekTYPErBaseIntm
  = \ @k @b @m @r $dMonadHeapPrint1 $dPrintClosure34 ->
      C:PrintClosure
        ($cp1PrintClosure3 $dMonadHeapPrint1 $dPrintClosure34)
        ($cpClosImpl12 $dMonadHeapPrint1 $dPrintClosure34)

heapIsBound
  = \ @t @m $dMonadHeapPrint1 ->
      let { $dFunctor = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dFunctor1 = $p1Monad $dFunctor } in
      let { $dFunctor2 = $p1Applicative $dFunctor1 } in
      \ i ->
        fmap $dFunctor2 (member i) (getHeapBindings $dMonadHeapPrint1)

lookupHeapUnbound
  = \ @t @m $dMonadHeapPrint1 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ i ->
        >>=
          $dMonad1
          (heapIsBound $dMonadHeapPrint1 i)
          (\ ds ->
             case ds of {
               False ->
                 fmap
                   $dFunctor
                   (\ ds1 ->
                      lookup
                        i (ds1 `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t)))
                   (getHeapContent $dMonadHeapPrint1);
               True -> pure $dApplicative1 Nothing
             })

$cpClosImpl13
  = \ @k @k1 @b @m @r @f $dMonadHeapPrint1 $dPrintClosure34 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      \ $dIP4 _ prec hge0 ->
        >>=
          $dMonad1
          (>>=
             $dMonad1
             (let {
                ds
                  = let {
                      ds1 = case hge0 of { HeapGraphEntry ds2 ds3 ds4 ds5 -> ds3 } } in
                    case ds1 of {
                      __DEFAULT -> Nothing;
                      ConstrClosure ds2 ds3 ds4 ds5 ds6 ds7 ->
                        case eqString ds7 (unpackCString# "Text"#) of {
                          False -> Nothing;
                          True ->
                            case ds4 of {
                              [] -> Nothing;
                              : len ds8 ->
                                case ds8 of {
                                  [] -> Nothing;
                                  : offs ds9 ->
                                    case ds9 of {
                                      [] ->
                                        case ds3 of {
                                          [] -> Nothing;
                                          : p ds10 ->
                                            case ds10 of {
                                              [] -> Just (len, offs, p);
                                              : ipv ipv1 -> Nothing
                                            }
                                        };
                                      : ipv ipv1 -> Nothing
                                    }
                                }
                            }
                        }
                    } } in
              case ds of {
                Nothing -> return $dMonad1 Nothing;
                Just a -> return $dMonad1 (Just a)
              })
             (\ v ->
                case v of {
                  Nothing -> return $dMonad1 Nothing;
                  Just y ->
                    case y of { (len, offs, ds) ->
                    case ds of {
                      Nothing -> return $dMonad1 Nothing;
                      Just p ->
                        >>=
                          $dMonad1
                          (lookupHeapUnbound $dMonadHeapPrint1 p)
                          (\ v1 ->
                             case v1 of {
                               Nothing -> return $dMonad1 Nothing;
                               Just y1 ->
                                 case y1 of { HeapGraphEntry ds1 ds2 ds3 ds4 ->
                                 case ds2 of {
                                   __DEFAULT -> return $dMonad1 Nothing;
                                   ArrWordsClosure ds5 bx ds6 ->
                                     return
                                       $dMonad1
                                       (Just
                                          (case unsafeCoerce ds1 of { ByteArray unbx ->
                                           case fromIntegral $fIntegralWord $fNumInt len of
                                           { I# unbx1 ->
                                           case fromIntegral $fIntegralWord $fNumInt offs of
                                           { I# unbx2 ->
                                           Text unbx unbx1 unbx2
                                           }
                                           }
                                           }))
                                 }
                                 }
                             })
                    }
                    }
                }))
          (\ ds ->
             case ds of {
               Nothing ->
                 (super2
                    ((pClos1 $dIP4 $dPrintClosure34 prec hge0)
                     `cast` <Co:13> :: m (Doc Attr)
                                       ~R# Dispatch (PrettyText f) r f (m (Doc Attr))))
                 `cast` <Co:12> :: Dispatch (PrettyText f) r f (m (Doc Attr))
                                   ~R# m (Doc Attr);
               Just s ->
                 pure
                   $dApplicative1 ($fPrettyChar_$cprettyList ($fShowText_$cshow s))
             })

$fPrintClosurekTYPErPrettyTextHeapGraphEntrym
  = \ @k @k1 @b @m @r @f $dMonadHeapPrint1 $dPrintClosure34 ->
      C:PrintClosure
        ($cp1PrintClosure4 $dMonadHeapPrint1 $dPrintClosure34)
        ($cpClosImpl13 $dMonadHeapPrint1 $dPrintClosure34)

(!!!)
  = \ @v $dIP4 ->
      let {
        $dIP5
          = pushCallStack
              (unpackCString# "error"#,
               SrcLoc
                 (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
                 (unpackCString# "HeapUtils"#)
                 (unpackCString# "src/HeapUtils.hs"#)
                 (I# 374#)
                 (I# 16#)
                 (I# 374#)
                 (I# 21#))
              ($dIP4 `cast` <Co:3> :: (?callStack::CallStack) ~R# CallStack) } in
      \ m k ->
        case lookup k m of {
          Nothing ->
            error
              ($dIP5 `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
              (++
                 (unpackCString# "HeapGraph.!!!: key "#)
                 (case k of { I# n ->
                  ++ (itos n []) (unpackCString# " not found"#)
                  }));
          Just v1 -> v1
        }

$dIP3
  = pushCallStack
      (unpackCString# "!!!"#,
       SrcLoc
         (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
         (unpackCString# "HeapUtils"#)
         (unpackCString# "src/HeapUtils.hs"#)
         (I# 370#)
         (I# 16#)
         (I# 370#)
         (I# 19#))
      emptyCallStack

mkBindingMap
  = \ @t ds ->
      let {
        bindings
          = nubOrd
              $fOrdInt
              (: (I# 0#)
                 (let { v = > $fOrdInteger } in
                  let { v1 = IS 1# } in
                  letrec {
                    go1
                      = \ ds1 ->
                          case ds1 of {
                            [] -> [];
                            : y ys ->
                              let { z = go1 ys } in
                              letrec {
                                go2
                                  = \ ds2 ->
                                      case ds2 of {
                                        [] -> z;
                                        : y1 ys1 -> : y1 (go2 ys1)
                                      }; } in
                              go2
                                (catMaybes
                                   (allClosures
                                      (case y of { HeapGraphEntry ds2 ds3 ds4 ds5 -> ds3 })))
                          }; } in
                  keys1
                    []
                    (filterWithKey
                       (\ _ x -> v x v1)
                       (fromListWithKey
                          $fOrdInt
                          (\ _ x y -> integerAdd x y)
                          (map
                             (\ ds1 -> (ds1, IS 1#))
                             (go1
                                (elems
                                   (ds
                                    `cast` <Co:2> :: HeapGraph t
                                                     ~R# IntMap (HeapGraphEntry t))))))))) } in
      let {
        groupedBindings
          = letrec {
              ds1
                = \ ds2 ->
                    case ds2 of {
                      [] -> [];
                      : ds4 ds5 ->
                        : (case !!!
                                  ($dIP3 `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
                                  (ds `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t))
                                  ds4
                           of
                           { HeapGraphEntry ds6 ds7 ds8 ds9 ->
                           case ds7 of {
                             __DEFAULT -> C# 'x'#;
                             FunClosure ds10 ds11 ds12 -> C# 'f'#;
                             ThunkClosure ds10 ds11 ds12 -> C# 't'#;
                             SelectorClosure ds10 ds11 -> C# 't'#;
                             PAPClosure ds10 bx bx1 ds11 ds12 -> C# 'f'#;
                             APClosure ds10 bx bx1 ds11 ds12 -> C# 't'#;
                             BCOClosure ds10 ds11 ds12 ds13 bx bx1 ds14 -> C# 't'#
                           }
                           },
                           : ds4 [])
                          (ds1 ds5)
                    }; } in
            fromListWithKey $fOrdChar (\ _ x y -> ++ x y) (ds1 bindings) } in
      fromList
        (letrec {
           ds1
             = \ ds2 ->
                 case ds2 of {
                   [] -> [];
                   : ds4 ds5 ->
                     case ds4 of { (k, vs) ->
                     letrec {
                       ds6
                         = \ ds7 ->
                             case ds7 of {
                               [] -> ds1 ds5;
                               : ds9 ds10 ->
                                 case ds9 of { (v, idx) ->
                                 : (v, : k ($fShowInt_$cshow idx)) (ds6 ds10)
                                 }
                             }; } in
                     ds6 (zip vs (enumFrom $fEnumInt (I# 1#)))
                     }
                 }; } in
         ds1 (toAscList groupedBindings))

runHeapPrintT
  = \ @t @m @a ds hg ->
      (ds
       `cast` <Co:13> :: HeapPrintT t m a
                         ~R# ((HeapGraph t, IntMap String) -> m a))
        (hg, mkBindingMap hg)

$cpClosImpl14
  = \ @k @r @t @m $dPrintClosure34 $dMonadHeapPrint1 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      \ $dIP4 _ ->
        let {
          $dIP6
            = pushCallStack
                (unpackCString# "!!!"#,
                 SrcLoc
                   (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
                   (unpackCString# "HeapUtils"#)
                   (unpackCString# "src/HeapUtils.hs"#)
                   (I# 244#)
                   (I# 82#)
                   (I# 244#)
                   (I# 85#))
                emptyCallStack } in
        let {
          $dIP7
            = pushCallStack
                (unpackCString# "!!!"#,
                 SrcLoc
                   (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
                   (unpackCString# "HeapUtils"#)
                   (unpackCString# "src/HeapUtils.hs"#)
                   (I# 241#)
                   (I# 59#)
                   (I# 241#)
                   (I# 62#))
                emptyCallStack } in
        let {
          $dIP8
            = pushCallStack
                (unpackCString# "!!!"#,
                 SrcLoc
                   (unpackCString# "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#)
                   (unpackCString# "HeapUtils"#)
                   (unpackCString# "src/HeapUtils.hs"#)
                   (I# 241#)
                   (I# 45#)
                   (I# 241#)
                   (I# 48#))
                emptyCallStack } in
        \ _ ds ->
          case ds of { HeapRoot r1 ->
          >>=
            $dMonad1
            (getHeapBindings $dMonadHeapPrint1)
            (\ binds ->
               >>=
                 $dMonad1
                 (getHeapContent $dMonadHeapPrint1)
                 (\ ds1 ->
                    >>=
                      $dMonad1
                      (forM
                         $fTraversable[]
                         $dMonad1
                         (: r1
                            (filter
                               (\ v -> member v binds)
                               (keys
                                  (ds1
                                   `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t)))))
                         ((\ k1 ->
                             self2
                               (let { a = I# 0# } in
                                let {
                                  b = !!!
                                        ($dIP8
                                         `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
                                        binds
                                        k1 } in
                                let {
                                  b1
                                    = !!!
                                        ($dIP7
                                         `cast` <Co:4> :: CallStack ~R# (?callStack::CallStack))
                                        (ds1
                                         `cast` <Co:2> :: HeapGraph t ~R# IntMap (HeapGraphEntry t))
                                        k1 } in
                                let { b2 = HeapKV k1 b b1 } in
                                (pClosImpl
                                   $dPrintClosure34
                                   $dIP4
                                   (proxy# `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                   a
                                   b2)
                                `cast` <Co:14> :: m (Doc Attr)
                                                  ~R# Dispatch Any r r (m (Doc Attr))))
                          `cast` <Co:16> :: (HeapGraphIndex
                                             -> Dispatch Any r r (m (Doc Attr)))
                                            ~R# (HeapGraphIndex -> m (Doc Attr))))
                      (\ kv ->
                         case member r1 binds of {
                           False ->
                             pure $dApplicative1 (list_$cfromString (unpackCString# "???"#));
                           True ->
                             pure
                               $dApplicative1
                               (let { x = list_$cfromString (unpackCString# "let"#) } in
                                let {
                                  y = vcat_$c<>
                                        (let { d = vcat kv } in
                                         column
                                           (\ k1 ->
                                              nesting
                                                (\ i ->
                                                   case k1 of { I# x1 ->
                                                   case i of { I# y1 ->
                                                   let { ds2 = -# x1 y1 } in
                                                   case ds2 of ds3 {
                                                     __DEFAULT -> Nest ds3 d;
                                                     0# -> d
                                                   }
                                                   }
                                                   })))
                                        (vcat_$c<>
                                           line
                                           (vcat_$c<>
                                              (list_$cfromString (unpackCString# " in "#))
                                              ($fPrettyChar_$cprettyList
                                                 (!!!
                                                    ($dIP6
                                                     `cast` <Co:4> :: CallStack
                                                                      ~R# (?callStack::CallStack))
                                                    binds
                                                    r1)))) } in
                                vcat_$c<> x (vcat_$c<> line1 y))
                         })))
          }

$fPrintClosurekTYPErBaseHeapRootm
  = \ @k @r @t @m $dPrintClosure34 $dMonadHeapPrint1 ->
      C:PrintClosure
        ($cp1PrintClosure5 $dPrintClosure34 $dMonadHeapPrint1)
        ($cpClosImpl14 $dPrintClosure34 $dMonadHeapPrint1)

$cpClosImpl15
  = \ @k
      @k1
      @b
      @m
      @r
      @f
      $dMonadHeapPrint1
      $dPrintClosure34
      $dPrintClosure35 ->
      let { $dMonad1 = $p1MonadHeapPrint $dMonadHeapPrint1 } in
      let { $dApplicative1 = $p1Monad $dMonad1 } in
      let { $dFunctor = $p1Applicative $dApplicative1 } in
      \ $dIP4 _ prec hge0 ->
        letrec {
          isList
            = \ @a hge ->
                join {
                  $j
                    = (>>=
                         $dMonad1
                         (let {
                            ds
                              = isCons
                                  (case hge of { HeapGraphEntry ds1 ds2 ds3 ds4 -> ds2 }) } in
                          case ds of {
                            Nothing -> return $dMonad1 Nothing;
                            Just a1 -> return $dMonad1 (Just a1)
                          })
                         (\ v ->
                            case v of {
                              Nothing -> return $dMonad1 Nothing;
                              Just y ->
                                case y of { (h, t) ->
                                >>=
                                  $dMonad1
                                  (case t of {
                                     Nothing -> return $dMonad1 Nothing;
                                     Just a1 -> return $dMonad1 (Just a1)
                                   })
                                  (\ v1 ->
                                     case v1 of {
                                       Nothing -> return $dMonad1 Nothing;
                                       Just y1 ->
                                         >>=
                                           $dMonad1
                                           (lookupHeapUnbound $dMonadHeapPrint1 y1)
                                           (\ v2 ->
                                              case v2 of {
                                                Nothing -> return $dMonad1 Nothing;
                                                Just y2 ->
                                                  fmap
                                                    $dFunctor
                                                    (\ ds1 ->
                                                       case ds1 of {
                                                         Nothing -> Nothing;
                                                         Just a1 -> Just (: h a1)
                                                       })
                                                    ((isList y2)
                                                     `cast` <Co:5> :: MaybeT
                                                                        m [Maybe HeapGraphIndex]
                                                                      ~R# m (Maybe
                                                                               [Maybe
                                                                                  HeapGraphIndex]))
                                              })
                                     })
                                }
                            }))
                      `cast` <Co:6> :: m (Maybe [Maybe HeapGraphIndex])
                                       ~R# MaybeT m [Maybe HeapGraphIndex] } in
                case hge of { HeapGraphEntry ds1 ds2 ds3 ds4 ->
                case ds2 of {
                  __DEFAULT -> jump $j;
                  ConstrClosure ds ds7 ds8 ds9 ds10 ds11 ->
                    case eqString ds11 (unpackCString# "[]"#) of {
                      False -> jump $j;
                      True ->
                        case ds8 of {
                          [] ->
                            case ds7 of {
                              [] ->
                                (return $dMonad1 (Just []))
                                `cast` <Co:6> :: m (Maybe [Maybe HeapGraphIndex])
                                                 ~R# MaybeT m [Maybe HeapGraphIndex];
                              : ipv ipv1 -> jump $j
                            };
                          : ipv ipv1 -> jump $j
                        }
                    }
                }
                }; } in
        >>=
          $dMonad1
          (let { $dMonad2 = $fMonadMaybeT $dMonad1 } in
           >>=
             $dMonad1
             ((isList hge0)
              `cast` <Co:5> :: MaybeT m [Maybe HeapGraphIndex]
                               ~R# m (Maybe [Maybe HeapGraphIndex]))
             (\ v ->
                case v of {
                  Nothing -> return $dMonad1 Nothing;
                  Just y ->
                    case y of wild1 {
                      [] -> return $dMonad1 Nothing;
                      : ds1 ds2 ->
                        (mapM
                           $fTraversable[]
                           $dMonad2
                           (let { g = lookupHeapUnbound $dMonadHeapPrint1 } in
                            (\ eta ->
                               >>=
                                 $dMonad1
                                 (>>=
                                    $dMonad1
                                    (case eta of {
                                       Nothing -> return $dMonad1 Nothing;
                                       Just a -> return $dMonad1 (Just a)
                                     })
                                    (\ v1 ->
                                       case v1 of {
                                         Nothing -> return $dMonad1 Nothing;
                                         Just y1 -> g y1
                                       }))
                                 (\ v1 ->
                                    case v1 of {
                                      Nothing -> return $dMonad1 Nothing;
                                      Just y1 ->
                                        let {
                                          ds
                                            = isChar
                                                (case y1 of { HeapGraphEntry ds4 ds5 ds3 ds6 ->
                                                 ds5
                                                 }) } in
                                        case ds of {
                                          Nothing -> return $dMonad1 Nothing;
                                          Just a -> return $dMonad1 (Just a)
                                        }
                                    }))
                            `cast` <Co:8> :: (Maybe HeapGraphIndex -> m (Maybe Char))
                                             ~R# (Maybe HeapGraphIndex -> MaybeT m Char))
                           wild1)
                        `cast` <Co:3> :: MaybeT m String ~R# m (Maybe String)
                    }
                }))
          (\ ds ->
             case ds of {
               Nothing ->
                 >>=
                   $dMonad1
                   ((isList hge0)
                    `cast` <Co:5> :: MaybeT m [Maybe HeapGraphIndex]
                                     ~R# m (Maybe [Maybe HeapGraphIndex]))
                   (\ ds1 ->
                      case ds1 of {
                        Nothing ->
                          >>=
                            $dMonad1
                            (getHeapContent $dMonadHeapPrint1)
                            (\ _ ->
                               case disassembleBCO1 of {
                                 Nothing ->
                                   (super2
                                      ((pClos1 $dIP4 $dPrintClosure35 prec hge0)
                                       `cast` <Co:13> :: m (Doc Attr)
                                                         ~R# Dispatch
                                                               (PrettyListLiterals f)
                                                               r
                                                               f
                                                               (m (Doc Attr))))
                                   `cast` <Co:12> :: Dispatch
                                                       (PrettyListLiterals f) r f (m (Doc Attr))
                                                     ~R# m (Doc Attr);
                                 Just bc ->
                                   fmap
                                     $dFunctor
                                     (\ o ->
                                        app prec (: (list_$cfromString (unpackCString# "_bco"#)) o))
                                     (traverse
                                        $fTraversable[]
                                        $dApplicative1
                                        (let { a = I# 10# } in
                                         (\ x ->
                                            self2
                                              ((pClosImpl
                                                  $dPrintClosure34
                                                  $dIP4
                                                  (proxy#
                                                   `cast` <Co:6> :: Proxy# r
                                                                    ~R# (?printLocal::Proxy# r))
                                                  a
                                                  x)
                                               `cast` <Co:14> :: m (Doc Attr)
                                                                 ~R# Dispatch
                                                                       Any r r (m (Doc Attr))))
                                         `cast` <Co:17> :: (Maybe HeapGraphIndex
                                                            -> Dispatch Any r r (m (Doc Attr)))
                                                           ~R# (Maybe HeapGraphIndex
                                                                -> m (Doc Attr)))
                                        (letrec {
                                           go1
                                             = \ ds3 ->
                                                 case ds3 of {
                                                   [] -> [];
                                                   : y ys ->
                                                     let { z = go1 ys } in
                                                     letrec {
                                                       go2
                                                         = \ ds4 ->
                                                             case ds4 of {
                                                               [] -> z;
                                                               : y1 ys1 -> : y1 (go2 ys1)
                                                             }; } in
                                                     go2 ($fFoldableBCI_$ctoList y)
                                                 }; } in
                                         go1 bc))
                               });
                        Just l ->
                          fmap
                            $dFunctor
                            list
                            (traverse
                               $fTraversable[]
                               $dApplicative1
                               (let { a = I# 0# } in
                                (\ x ->
                                   self2
                                     ((pClosImpl
                                         $dPrintClosure34
                                         $dIP4
                                         (proxy#
                                          `cast` <Co:6> :: Proxy# r ~R# (?printLocal::Proxy# r))
                                         a
                                         x)
                                      `cast` <Co:14> :: m (Doc Attr)
                                                        ~R# Dispatch Any r r (m (Doc Attr))))
                                `cast` <Co:17> :: (Maybe HeapGraphIndex
                                                   -> Dispatch Any r r (m (Doc Attr)))
                                                  ~R# (Maybe HeapGraphIndex -> m (Doc Attr)))
                               l)
                      });
               Just s ->
                 pure
                   $dApplicative1
                   ($fPrettyChar_$cprettyList
                      (: $fShow(,)13 (showLitString s (: $fShow(,)13 []))))
             })

$fPrintClosurekTYPErPrettyListLiteralsHeapGraphEntrym
  = \ @k
      @k1
      @b
      @m
      @r
      @f
      $dMonadHeapPrint1
      $dPrintClosure34
      $dPrintClosure35 ->
      C:PrintClosure
        ($p1Monad ($p1MonadHeapPrint $dMonadHeapPrint1))
        ($cpClosImpl15 $dMonadHeapPrint1 $dPrintClosure34 $dPrintClosure35)

$trModule1 = "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#

$trModule2 = TrNameS $trModule1

$trModule3 = "HeapUtils"#

$trModule4 = TrNameS $trModule3

$trModule = Module $trModule2 $trModule4

$krep = "\"printLocal\""#

$krep1 = KindRepTypeLitS TypeLitSymbol $krep

$krep2 = "\"printBase\""#

$krep3 = KindRepTypeLitS TypeLitSymbol $krep2

$krep4 = KindRepTyConApp $tcInt []

$krep5 = KindRepTyConApp $tcConstraint []

$krep6 = KindRepTyConApp $tcAttr []

$krep7 = KindRepTyConApp $tcChar []

$krep8 = : $krep6 []

$krep9 = KindRepTyConApp $tcDoc $krep8

$krep10 = : $krep6 []

$krep11 = KindRepTyConApp $tcIntMap $krep10

$krep12 = : $krep7 []

$krep13 = KindRepTyConApp $tc[] $krep12

$krep14 = : $krep13 []

$krep15 = KindRepTyConApp $tcIntMap $krep14

$krep16 = KindRepFun krep$*Arr* $krep5

$krep17 = KindRepFun krep$* $krep16

$krep18 = KindRepFun krep$*Arr* krep$*Arr*

$krep19 = KindRepFun krep$* $krep18

$krep20 = KindRepVar 4#

$krep21 = KindRepVar 2#

$krep22 = KindRepVar 1#

$krep23 = KindRepFun $krep22 $krep17

$krep24 = KindRepFun $krep22 krep$*

$krep25 = KindRepVar 0#

$krep26 = KindRepFun $krep25 $krep23

$krep27 = KindRepFun $krep25 $krep24

$krep28 = KindRepFun $krep25 krep$*

$krep29 = : $krep25 []

$krep30 = KindRepTyConApp $tcHeapGraph $krep29

$krep31 = : $krep15 []

$krep32 = : $krep30 $krep31

$krep33 = KindRepTyConApp $tc(,) $krep32

$krep34 = : $krep25 []

$krep35 = KindRepTyConApp $tcHeapGraphEntry $krep34

$krep36 = KindRepVar 5#

$krep37 = KindRepApp $krep36 $krep9

$krep38 = KindRepFun $krep20 $krep37

$krep39 = KindRepFun $krep4 $krep38

$krep40 = : $krep36 []

$krep41 = KindRepTyConApp $tcApplicative $krep40

$krep42 = KindRepVar 1#

$krep43 = KindRepApp $krep42 $krep15

$krep44 = KindRepApp $krep42 $krep30

$krep45 = : $krep21 []

$krep46 = : $krep42 $krep45

$krep47 = : $krep33 $krep46

$krep48 = KindRepTyConApp $tcReaderT $krep47

$krep49 = : $krep42 []

$krep50 = KindRepTyConApp $tcMonad $krep49

$krep51 = KindRepVar 0#

$krep52 = KindRepApp $krep51 $krep11

$krep53 = : $krep22 []

$krep54 = : $krep51 $krep53

$krep55 = : $krep11 $krep54

$krep56 = KindRepTyConApp $tcReaderT $krep55

$krep57 = : $krep51 []

$krep58 = KindRepTyConApp $tcMonad $krep57

$krep59 = KindRepVar 3#

$krep60 = : $krep59 []

$krep61 = : $krep22 $krep60

$krep62 = KindRepTyConApp $tcProxy# $krep61

$krep63 = : $krep62 []

$krep64 = : $krep1 $krep63

$krep65 = KindRepTyConApp $tcIP $krep64

$krep66 = KindRepFun $krep65 $krep39

$krep67 = KindRepVar 2#

$krep68 = : $krep67 []

$krep69 = : $krep25 $krep68

$krep70 = KindRepTyConApp $tcProxy# $krep69

$krep71 = : $krep70 []

$krep72 = : $krep3 $krep71

$krep73 = KindRepTyConApp $tcIP $krep72

$krep74 = KindRepFun $krep73 $krep66

$tcNamedThunks1 = "NamedThunks"#

$tcNamedThunks2 = TrNameS $tcNamedThunks1

$tcNamedThunks
  = TyCon
      16940524130248433816##64
      10703467182719248520##64
      $trModule
      $tcNamedThunks2
      1#
      $krep28

$tcPrettyListLiterals1 = "PrettyListLiterals"#

$tcPrettyListLiterals2 = TrNameS $tcPrettyListLiterals1

$tcPrettyListLiterals
  = TyCon
      1475729845294341320##64
      5940317455928483254##64
      $trModule
      $tcPrettyListLiterals2
      1#
      $krep28

$tcPrettyText1 = "PrettyText"#

$tcPrettyText2 = TrNameS $tcPrettyText1

$tcPrettyText
  = TyCon
      13983549703678983486##64
      10705492752301131532##64
      $trModule
      $tcPrettyText2
      1#
      $krep28

$tcElide1 = "Elide"#

$tcElide2 = TrNameS $tcElide1

$tcElide
  = TyCon
      15258727981397965161##64
      5046812752541504967##64
      $trModule
      $tcElide2
      2#
      $krep27

$tcPrintClosure1 = "PrintClosure"#

$tcPrintClosure2 = TrNameS $tcPrintClosure1

$tcPrintClosure
  = TyCon
      10715870330730227162##64
      2891202511837432102##64
      $trModule
      $tcPrintClosure2
      2#
      $krep26

$krep75 = : $krep36 []

$krep76 = : $krep20 $krep75

$krep77 = : $krep59 $krep76

$krep78 = : $krep67 $krep77

$krep79 = : $krep22 $krep78

$krep80 = : $krep25 $krep79

$krep81 = KindRepTyConApp $tcPrintClosure $krep80

$krep82 = KindRepFun $krep74 $krep81

$krep83 = KindRepFun $krep41 $krep82

$tc'C:PrintClosure1 = "'C:PrintClosure"#

$tc'C:PrintClosure2 = TrNameS $tc'C:PrintClosure1

$tc'C:PrintClosure
  = TyCon
      12792363699917352936##64
      17330472865061592089##64
      $trModule
      $tc'C:PrintClosure2
      6#
      $krep83

$tcHeapRoot1 = "HeapRoot"#

$tcHeapRoot2 = TrNameS $tcHeapRoot1

$tcHeapRoot
  = TyCon
      16320787393839418248##64
      12231918735598989381##64
      $trModule
      $tcHeapRoot2
      0#
      krep$*

$krep84 = KindRepTyConApp $tcHeapRoot []

$krep85 = KindRepFun $krep4 $krep84

$tc'HeapRoot1 = "'HeapRoot"#

$tc'HeapRoot2 = TrNameS $tc'HeapRoot1

$tc'HeapRoot
  = TyCon
      15116345743578642687##64
      4088251164208122752##64
      $trModule
      $tc'HeapRoot2
      0#
      $krep85

$tcHeapKV1 = "HeapKV"#

$tcHeapKV2 = TrNameS $tcHeapKV1

$tcHeapKV
  = TyCon
      15442278164442099450##64
      9590314007206807240##64
      $trModule
      $tcHeapKV2
      0#
      krep$*Arr*

$krep86 = : $krep25 []

$krep87 = KindRepTyConApp $tcHeapKV $krep86

$krep88 = KindRepFun $krep35 $krep87

$krep89 = KindRepFun $krep13 $krep88

$krep90 = KindRepFun $krep4 $krep89

$tc'HeapKV1 = "'HeapKV"#

$tc'HeapKV2 = TrNameS $tc'HeapKV1

$tc'HeapKV
  = TyCon
      13472336734162458493##64
      17632476175039328017##64
      $trModule
      $tc'HeapKV2
      1#
      $krep90

$tcMonadDecorate1 = "MonadDecorate"#

$tcMonadDecorate2 = TrNameS $tcMonadDecorate1

$tcMonadDecorate
  = TyCon
      5858529179829584112##64
      10179153855110236700##64
      $trModule
      $tcMonadDecorate2
      0#
      $krep16

$krep91 = : $krep51 []

$krep92 = KindRepTyConApp $tcMonadDecorate $krep91

$krep93 = KindRepFun $krep52 $krep92

$krep94 = KindRepFun $krep58 $krep93

$tc'C:MonadDecorate1 = "'C:MonadDecorate"#

$tc'C:MonadDecorate2 = TrNameS $tc'C:MonadDecorate1

$tc'C:MonadDecorate
  = TyCon
      2472037496869253838##64
      2509609770210679684##64
      $trModule
      $tc'C:MonadDecorate2
      1#
      $krep94

$tcDecorateElems1 = "DecorateElems"#

$tcDecorateElems2 = TrNameS $tcDecorateElems1

$tcDecorateElems
  = TyCon
      9865056640784120570##64
      10186460409221579448##64
      $trModule
      $tcDecorateElems2
      1#
      $krep28

$tcMonadHeapPrint1 = "MonadHeapPrint"#

$tcMonadHeapPrint2 = TrNameS $tcMonadHeapPrint1

$tcMonadHeapPrint
  = TyCon
      14334595219621928100##64
      1763771378747849501##64
      $trModule
      $tcMonadHeapPrint2
      0#
      $krep17

$krep95 = : $krep42 []

$krep96 = : $krep25 $krep95

$krep97 = KindRepTyConApp $tcMonadHeapPrint $krep96

$krep98 = KindRepFun $krep44 $krep97

$krep99 = KindRepFun $krep43 $krep98

$krep100 = KindRepFun $krep50 $krep99

$tc'C:MonadHeapPrint1 = "'C:MonadHeapPrint"#

$tc'C:MonadHeapPrint2 = TrNameS $tc'C:MonadHeapPrint1

$tc'C:MonadHeapPrint
  = TyCon
      15231624055606598072##64
      17610450527297938827##64
      $trModule
      $tc'C:MonadHeapPrint2
      2#
      $krep100

$tcDecorateT1 = "DecorateT"#

$tcDecorateT2 = TrNameS $tcDecorateT1

$tcDecorateT
  = TyCon
      17511994562757618798##64
      9250041382521115799##64
      $trModule
      $tcDecorateT2
      0#
      $krep18

$krep101 = : $krep22 []

$krep102 = : $krep51 $krep101

$krep103 = KindRepTyConApp $tcDecorateT $krep102

$krep104 = KindRepFun $krep56 $krep103

$tc'DecorateT1 = "'DecorateT"#

$tc'DecorateT2 = TrNameS $tc'DecorateT1

$tc'DecorateT
  = TyCon
      5288258427052301176##64
      7571200242534887037##64
      $trModule
      $tc'DecorateT2
      2#
      $krep104

$tcHeapPrintT1 = "HeapPrintT"#

$tcHeapPrintT2 = TrNameS $tcHeapPrintT1

$tcHeapPrintT
  = TyCon
      7524692127510196217##64
      15532567376436988153##64
      $trModule
      $tcHeapPrintT2
      0#
      $krep19

$krep105 = : $krep21 []

$krep106 = : $krep42 $krep105

$krep107 = : $krep25 $krep106

$krep108 = KindRepTyConApp $tcHeapPrintT $krep107

$krep109 = KindRepFun $krep48 $krep108

$tc'HeapPrintT1 = "'HeapPrintT"#

$tc'HeapPrintT2 = TrNameS $tc'HeapPrintT1

$tc'HeapPrintT
  = TyCon
      14711388777412766433##64
      15097871142319285211##64
      $trModule
      $tc'HeapPrintT2
      3#
      $krep109

$dApplicative = $fApplicativeDecorateT $fApplicativeIdentity

$dPrintClosure = $fPrintClosurekTYPErElidetm $dApplicative

$dMonad = $fMonadDecorateT $fMonadIdentity

$dMonadHeapPrint = $fMonadHeapPrinttHeapPrintT $dMonad

$dMonadDecorate = $fMonadDecorateDecorateT $fMonadIdentity

$dPrintClosure1
  = $fPrintClosurekTYPErDecorateElemsbm
      $dPrintClosure $dMonadDecorate

$dPrintClosure2 = $fPrintClosurekTYPErPrettyTextbm $dPrintClosure1

ppClosureDoc
  = \ a b c ->
      runIdentity
        (((self2
             ((super2
                 ((super2
                     ((super2
                         ((super2
                             ((super2
                                 (($cpClosImpl11
                                     $dPrintClosure2
                                     (proxy#
                                      `cast` <Co:6> :: Proxy# Printer
                                                       ~R# (?printBase::Proxy# Printer))
                                     (proxy#
                                      `cast` <Co:6> :: Proxy# Base ~R# (?printLocal::Proxy# Base))
                                     b
                                     c)
                                  `cast` <Co:26> :: DecorateT Identity (Doc Attr)
                                                    ~R# Dispatch
                                                          (NamedThunks Base)
                                                          (PrettyText
                                                             (DecorateElems
                                                                (Elide
                                                                   HeapData
                                                                   (PrettyListLiterals
                                                                      (NamedThunks Base)))))
                                                          Base
                                                          (DecorateT Identity (Doc Attr))))
                              `cast` <Co:56> :: Dispatch
                                                  (NamedThunks Base)
                                                  (PrettyText
                                                     (DecorateElems
                                                        (Elide
                                                           HeapData
                                                           (PrettyListLiterals
                                                              (NamedThunks Base)))))
                                                  Base
                                                  (DecorateT Identity (Doc Attr))
                                                ~R# Dispatch
                                                      (PrettyListLiterals (NamedThunks Base))
                                                      (PrettyText
                                                         (DecorateElems
                                                            (Elide
                                                               HeapData
                                                               (PrettyListLiterals
                                                                  (NamedThunks Base)))))
                                                      (NamedThunks Base)
                                                      (DecorateT Identity (Doc Attr))))
                          `cast` <Co:66> :: Dispatch
                                              (PrettyListLiterals (NamedThunks Base))
                                              (PrettyText
                                                 (DecorateElems
                                                    (Elide
                                                       HeapData
                                                       (PrettyListLiterals (NamedThunks Base)))))
                                              (NamedThunks Base)
                                              (DecorateT Identity (Doc Attr))
                                            ~R# Dispatch
                                                  (Elide
                                                     HeapData
                                                     (PrettyListLiterals (NamedThunks Base)))
                                                  (PrettyText
                                                     (DecorateElems
                                                        (Elide
                                                           HeapData
                                                           (PrettyListLiterals
                                                              (NamedThunks Base)))))
                                                  (PrettyListLiterals (NamedThunks Base))
                                                  (DecorateT Identity (Doc Attr))))
                      `cast` <Co:78> :: Dispatch
                                          (Elide HeapData (PrettyListLiterals (NamedThunks Base)))
                                          (PrettyText
                                             (DecorateElems
                                                (Elide
                                                   HeapData
                                                   (PrettyListLiterals (NamedThunks Base)))))
                                          (PrettyListLiterals (NamedThunks Base))
                                          (DecorateT Identity (Doc Attr))
                                        ~R# Dispatch
                                              (DecorateElems
                                                 (Elide
                                                    HeapData
                                                    (PrettyListLiterals (NamedThunks Base))))
                                              (PrettyText
                                                 (DecorateElems
                                                    (Elide
                                                       HeapData
                                                       (PrettyListLiterals (NamedThunks Base)))))
                                              (Elide
                                                 HeapData (PrettyListLiterals (NamedThunks Base)))
                                              (DecorateT Identity (Doc Attr))))
                  `cast` <Co:88> :: Dispatch
                                      (DecorateElems
                                         (Elide HeapData (PrettyListLiterals (NamedThunks Base))))
                                      (PrettyText
                                         (DecorateElems
                                            (Elide
                                               HeapData (PrettyListLiterals (NamedThunks Base)))))
                                      (Elide HeapData (PrettyListLiterals (NamedThunks Base)))
                                      (DecorateT Identity (Doc Attr))
                                    ~R# Dispatch
                                          (PrettyText
                                             (DecorateElems
                                                (Elide
                                                   HeapData
                                                   (PrettyListLiterals (NamedThunks Base)))))
                                          (PrettyText
                                             (DecorateElems
                                                (Elide
                                                   HeapData
                                                   (PrettyListLiterals (NamedThunks Base)))))
                                          (DecorateElems
                                             (Elide
                                                HeapData (PrettyListLiterals (NamedThunks Base))))
                                          (DecorateT Identity (Doc Attr))))
              `cast` <Co:61> :: Dispatch
                                  (PrettyText
                                     (DecorateElems
                                        (Elide HeapData (PrettyListLiterals (NamedThunks Base)))))
                                  (PrettyText
                                     (DecorateElems
                                        (Elide HeapData (PrettyListLiterals (NamedThunks Base)))))
                                  (DecorateElems
                                     (Elide HeapData (PrettyListLiterals (NamedThunks Base))))
                                  (DecorateT Identity (Doc Attr))
                                ~R# Dispatch Any Printer Printer (DecorateT Identity (Doc Attr))))
          `cast` <Co:26> :: Dispatch
                              Any Printer Printer (DecorateT Identity (Doc Attr))
                            ~R# (IntMap Attr -> Identity (Doc Attr)))
           a)

$dMonadDecorate1 = $fMonadDecorateHeapPrintT $dMonadDecorate

Rec {
$dPrintClosure3 = $fPrintClosurekTYPErElidesm $dPrintClosure26

$dPrintClosure4
  = $fPrintClosurekTYPErDecorateElemsbm
      $dPrintClosure3 $dMonadDecorate1

$dPrintClosure5
  = $fPrintClosurekTYPErPrettyTextHeapGraphEntrym
      $dMonadHeapPrint $dPrintClosure4

$dPrintClosure6
  = $fPrintClosurekTYPErBaseIntm $dMonadHeapPrint $dPrintClosure5

$dPrintClosure7 = $fPrintClosurekTYPErNamedThunksbm $dPrintClosure6

$dPrintClosure8
  = $fPrintClosurekTYPErPrettyListLiteralsbm $dPrintClosure7

$dPrintClosure9 = $fPrintClosurekTYPErElidesm $dPrintClosure8

$dPrintClosure10
  = $fPrintClosurekTYPErDecorateElemsIntm
      $dPrintClosure9 $dMonadDecorate1

$dPrintClosure11
  = $fPrintClosurekTYPErPrettyTextbm $dPrintClosure10

$dPrintClosure12 = $fPrintClosurekTYPErBaseMaybem $dPrintClosure11

$dPrintClosure13
  = $fPrintClosurekTYPErNamedThunksbm $dPrintClosure12

$dPrintClosure14
  = $fPrintClosurekTYPErPrettyListLiteralsbm $dPrintClosure13

$dPrintClosure15 = $fPrintClosurekTYPErElidesm $dPrintClosure14

$dPrintClosure16
  = $fPrintClosurekTYPErDecorateElemsbm
      $dPrintClosure15 $dMonadDecorate1

$dPrintClosure17
  = $fPrintClosurekTYPErPrettyTextbm $dPrintClosure16

$dPrintClosure18
  = $fPrintClosurekTYPErBaseGenClosurem $dPrintClosure17

$dPrintClosure19
  = $fPrintClosurekTYPErNamedThunksbm $dPrintClosure18

$dPrintClosure20
  = $fPrintClosurekTYPErPrettyListLiteralsbm $dPrintClosure19

$dPrintClosure21 = $fPrintClosurekTYPErElidesm $dPrintClosure20

$dPrintClosure22
  = $fPrintClosurekTYPErDecorateElemsbm
      $dPrintClosure21 $dMonadDecorate1

$dPrintClosure23
  = $fPrintClosurekTYPErPrettyTextbm $dPrintClosure22

$dPrintClosure24
  = $fPrintClosurekTYPErBaseHeapGraphEntrym $dPrintClosure23

$dPrintClosure25
  = $fPrintClosurekTYPErNamedThunksHeapGraphEntrym
      $dPrintClosure17 $dPrintClosure24

$dPrintClosure26
  = $fPrintClosurekTYPErPrettyListLiteralsHeapGraphEntrym
      $dMonadHeapPrint $dPrintClosure17 $dPrintClosure25
end Rec }

$dPrintClosure27
  = $fPrintClosurekTYPErPrettyTextHeapGraphEntrym
      $dMonadHeapPrint $dPrintClosure4

$dPrintClosure28
  = $fPrintClosurekTYPErBaseHeapKVm $dPrintClosure27 $dMonadHeapPrint

$dPrintClosure29
  = $fPrintClosurekTYPErNamedThunksbm $dPrintClosure28

$dPrintClosure30
  = $fPrintClosurekTYPErPrettyListLiteralsbm $dPrintClosure29

$dPrintClosure31 = $fPrintClosurekTYPErElidesm $dPrintClosure30

$dPrintClosure32
  = $fPrintClosurekTYPErDecorateElemsHeapKVm
      $dMonadDecorate1 $dPrintClosure31

$dPrintClosure33
  = $fPrintClosurekTYPErPrettyTextbm $dPrintClosure32

ppHeapGraph'
  = \ attrs hg ->
      runIdentity
        (let {
           ds
             = let { prec = I# 0# } in
               let { f = I# 0# } in
               let { f1 = HeapRoot f } in
               (self2
                  ((super2
                      ((super2
                          ((super2
                              ((super2
                                  ((super2
                                      (($cpClosImpl14
                                          $dPrintClosure33
                                          $dMonadHeapPrint
                                          (proxy#
                                           `cast` <Co:6> :: Proxy# Printer
                                                            ~R# (?printBase::Proxy# Printer))
                                          (proxy#
                                           `cast` <Co:6> :: Proxy# Base
                                                            ~R# (?printLocal::Proxy# Base))
                                          prec
                                          f1)
                                       `cast` <Co:28> :: HeapPrintT
                                                           HeapData (DecorateT Identity) (Doc Attr)
                                                         ~R# Dispatch
                                                               (NamedThunks Base)
                                                               (PrettyText
                                                                  (DecorateElems
                                                                     (Elide
                                                                        HeapData
                                                                        (PrettyListLiterals
                                                                           (NamedThunks Base)))))
                                                               Base
                                                               (HeapPrintT
                                                                  HeapData
                                                                  (DecorateT Identity)
                                                                  (Doc Attr))))
                                   `cast` <Co:60> :: Dispatch
                                                       (NamedThunks Base)
                                                       (PrettyText
                                                          (DecorateElems
                                                             (Elide
                                                                HeapData
                                                                (PrettyListLiterals
                                                                   (NamedThunks Base)))))
                                                       Base
                                                       (HeapPrintT
                                                          HeapData (DecorateT Identity) (Doc Attr))
                                                     ~R# Dispatch
                                                           (PrettyListLiterals (NamedThunks Base))
                                                           (PrettyText
                                                              (DecorateElems
                                                                 (Elide
                                                                    HeapData
                                                                    (PrettyListLiterals
                                                                       (NamedThunks Base)))))
                                                           (NamedThunks Base)
                                                           (HeapPrintT
                                                              HeapData
                                                              (DecorateT Identity)
                                                              (Doc Attr))))
                               `cast` <Co:70> :: Dispatch
                                                   (PrettyListLiterals (NamedThunks Base))
                                                   (PrettyText
                                                      (DecorateElems
                                                         (Elide
                                                            HeapData
                                                            (PrettyListLiterals
                                                               (NamedThunks Base)))))
                                                   (NamedThunks Base)
                                                   (HeapPrintT
                                                      HeapData (DecorateT Identity) (Doc Attr))
                                                 ~R# Dispatch
                                                       (Elide
                                                          HeapData
                                                          (PrettyListLiterals (NamedThunks Base)))
                                                       (PrettyText
                                                          (DecorateElems
                                                             (Elide
                                                                HeapData
                                                                (PrettyListLiterals
                                                                   (NamedThunks Base)))))
                                                       (PrettyListLiterals (NamedThunks Base))
                                                       (HeapPrintT
                                                          HeapData
                                                          (DecorateT Identity)
                                                          (Doc Attr))))
                           `cast` <Co:82> :: Dispatch
                                               (Elide
                                                  HeapData (PrettyListLiterals (NamedThunks Base)))
                                               (PrettyText
                                                  (DecorateElems
                                                     (Elide
                                                        HeapData
                                                        (PrettyListLiterals (NamedThunks Base)))))
                                               (PrettyListLiterals (NamedThunks Base))
                                               (HeapPrintT HeapData (DecorateT Identity) (Doc Attr))
                                             ~R# Dispatch
                                                   (DecorateElems
                                                      (Elide
                                                         HeapData
                                                         (PrettyListLiterals (NamedThunks Base))))
                                                   (PrettyText
                                                      (DecorateElems
                                                         (Elide
                                                            HeapData
                                                            (PrettyListLiterals
                                                               (NamedThunks Base)))))
                                                   (Elide
                                                      HeapData
                                                      (PrettyListLiterals (NamedThunks Base)))
                                                   (HeapPrintT
                                                      HeapData (DecorateT Identity) (Doc Attr))))
                       `cast` <Co:92> :: Dispatch
                                           (DecorateElems
                                              (Elide
                                                 HeapData (PrettyListLiterals (NamedThunks Base))))
                                           (PrettyText
                                              (DecorateElems
                                                 (Elide
                                                    HeapData
                                                    (PrettyListLiterals (NamedThunks Base)))))
                                           (Elide HeapData (PrettyListLiterals (NamedThunks Base)))
                                           (HeapPrintT HeapData (DecorateT Identity) (Doc Attr))
                                         ~R# Dispatch
                                               (PrettyText
                                                  (DecorateElems
                                                     (Elide
                                                        HeapData
                                                        (PrettyListLiterals (NamedThunks Base)))))
                                               (PrettyText
                                                  (DecorateElems
                                                     (Elide
                                                        HeapData
                                                        (PrettyListLiterals (NamedThunks Base)))))
                                               (DecorateElems
                                                  (Elide
                                                     HeapData
                                                     (PrettyListLiterals (NamedThunks Base))))
                                               (HeapPrintT
                                                  HeapData (DecorateT Identity) (Doc Attr))))
                   `cast` <Co:65> :: Dispatch
                                       (PrettyText
                                          (DecorateElems
                                             (Elide
                                                HeapData (PrettyListLiterals (NamedThunks Base)))))
                                       (PrettyText
                                          (DecorateElems
                                             (Elide
                                                HeapData (PrettyListLiterals (NamedThunks Base)))))
                                       (DecorateElems
                                          (Elide HeapData (PrettyListLiterals (NamedThunks Base))))
                                       (HeapPrintT HeapData (DecorateT Identity) (Doc Attr))
                                     ~R# Dispatch
                                           Any
                                           Printer
                                           Printer
                                           (HeapPrintT HeapData (DecorateT Identity) (Doc Attr))))
               `cast` <Co:16> :: Dispatch
                                   Any
                                   Printer
                                   Printer
                                   (HeapPrintT HeapData (DecorateT Identity) (Doc Attr))
                                 ~R# HeapPrintT HeapData (DecorateT Identity) (Doc Attr) } in
         (((ds
            `cast` <Co:17> :: HeapPrintT
                                HeapData (DecorateT Identity) (Doc Attr)
                              ~R# ((HeapGraph HeapData, IntMap String)
                                   -> DecorateT Identity (Doc Attr)))
             (hg, mkBindingMap hg))
          `cast` <Co:11> :: DecorateT Identity (Doc Attr)
                            ~R# (IntMap Attr -> Identity (Doc Attr)))
           attrs)



[9 of 9] Compiling Lib

/home/lana/Projects/HaskellDebug/src/Lib.hs:13:1: warning: [-Wunused-imports]
    The import of ‘Data.Text.Prettyprint.Doc’ is redundant
      except perhaps to import instances from ‘Data.Text.Prettyprint.Doc’
    To import instances alone, use: import Data.Text.Prettyprint.Doc()
   |
13 | import Data.Text.Prettyprint.Doc (pretty)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/lana/Projects/HaskellDebug/src/Lib.hs:13:1: warning: [-Wdeprecations]
    Module ‘Data.Text.Prettyprint.Doc’ is deprecated:
      "Use \"Prettyprinter\" instead."
   |
13 | import Data.Text.Prettyprint.Doc (pretty)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/lana/Projects/HaskellDebug/src/Lib.hs:28:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘foo’
   |
28 | foo ls =  scanl (+) 0 (map (*2) ls)
   | ^^^

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 58, types: 68, coercions: 8, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Lib.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 120 0}]
Lib.$trModule4 = "HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Lib.$trModule3 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Lib.$trModule3 = GHC.Types.TrNameS Lib.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Lib.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Lib.$trModule2 = "Lib"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Lib.$trModule1 :: GHC.Types.TrName
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Lib.$trModule1 = GHC.Types.TrNameS Lib.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Lib.$trModule :: GHC.Types.Module
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Lib.$trModule = GHC.Types.Module Lib.$trModule3 Lib.$trModule1

-- RHS size: {terms: 24, types: 29, coercions: 0, joins: 0/0}
Lib.someFunc4 :: Data.Text.Internal.Text
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 52 0}]
Lib.someFunc4
  = scc<someFunc>
    GHC.Magic.runRW#
      @GHC.Types.LiftedRep
      @Data.Text.Internal.Text
      (\ (s [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
         case GHC.Prim.newByteArray# @GHC.Prim.RealWorld 3# s of
         { (# ipv, ipv1 #) ->
         case GHC.Prim.copyAddrToByteArray#
                @GHC.Prim.RealWorld Lib.$trModule2 ipv1 0# 3# ipv
         of s2#
         { __DEFAULT ->
         case GHC.Prim.unsafeFreezeByteArray# @GHC.Prim.RealWorld ipv1 s2#
         of
         { (# ipv2, ipv3 #) ->
         Data.Text.Internal.Text ipv3 0# 3#
         }
         }
         })

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Lib.someFunc3 :: Int
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Lib.someFunc3 = GHC.Types.I# 25#

-- RHS size: {terms: 3, types: 2, coercions: 2, joins: 0/0}
Lib.someFunc2 :: Requests (Maybe GhcDump.Ast.Module)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 10}]
Lib.someFunc2
  = State.LoadGhcDump
      @(Maybe GhcDump.Ast.Module)
      @~(<Maybe GhcDump.Ast.Module>_N
         :: Maybe GhcDump.Ast.Module GHC.Prim.~# Maybe GhcDump.Ast.Module)
      (src<src/Lib.hs:17:33-37> Lib.someFunc4)
      (src<src/Lib.hs:17:39-40> Lib.someFunc3)

-- RHS size: {terms: 9, types: 17, coercions: 3, joins: 0/0}
Lib.someFunc1
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 50 0}]
Lib.someFunc1
  = tick<someFunc>
    \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      scc<someFunc>
      src<src/Lib.hs:(16,1)-(18,15)>
      case ((runRequest @(Maybe GhcDump.Ast.Module) Lib.someFunc2)
            `cast` (GHC.Types.N:IO[0] <Maybe GhcDump.Ast.Module>_R
                    :: IO (Maybe GhcDump.Ast.Module)
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                  Maybe GhcDump.Ast.Module #))))
             s
      of
      { (# ipv, ipv1 #) ->
      src<src/Lib.hs:18:4-15>
      UI.printValue1 @(Maybe GhcDump.Ast.Module) ipv1 ipv
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
someFunc :: IO ()
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
someFunc
  = Lib.someFunc1
    `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
            :: (GHC.Prim.State# GHC.Prim.RealWorld
                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
               ~R# IO ())



Preprocessing executable 'HaskellDebug-exe' for HaskellDebug-0.1.0.0..
Building executable 'HaskellDebug-exe' for HaskellDebug-0.1.0.0..
[3 of 3] Linking .stack-work/dist/x86_64-linux/Cabal-3.8.1.0/build/HaskellDebug-exe/HaskellDebug-exe [Library changed]
HaskellDebug> copy/register
Installing library in /home/lana/Projects/HaskellDebug/.stack-work/install/x86_64-linux/6c211dde4b0d6b67d82f393948408b23d5a2b3677671398eaf2d95c4f0aedc41/9.4.2/lib/x86_64-linux-ghc-9.4.2/HaskellDebug-0.1.0.0-5SCcCbvS7Jv6ivW2snQoVH
Installing executable HaskellDebug-exe in /home/lana/Projects/HaskellDebug/.stack-work/install/x86_64-linux/6c211dde4b0d6b67d82f393948408b23d5a2b3677671398eaf2d95c4f0aedc41/9.4.2/bin
Registering library for HaskellDebug-0.1.0.0..
